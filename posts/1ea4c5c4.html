<!DOCTYPE HTML>
<html lang="zh-CN">



<head>
    <meta charset="utf-8">
    <meta name="keywords" content="ConcurrentHashMap 源码阅读, Huowy&#39;Blog">
    <meta name="description" content="Huowy&#39;Blog">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-3Y2BMG1SZ8"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-3Y2BMG1SZ8');
</script>

        <title>
            ConcurrentHashMap 源码阅读 | Huowy&#39;Blog
        </title>
        <link rel="icon" type="image/jpeg" href="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/favicon.jpg">

        <link rel="stylesheet" type="text/css"
            href="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/awesome/css/all.css">
        <link rel="stylesheet" type="text/css"
            href="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/materialize/materialize.min.css">
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/aos/aos.css">
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/animate/animate.min.css">
        <link rel="stylesheet" type="text/css"
            href="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/lightGallery/css/lightgallery.min.css">
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/css/matery.css">
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/css/my.css">

        <script src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Huowy'Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>





<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    <div>
                    
                    <img src="../medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/medias/huowy.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Huowy&#39;Blog</span>
                    </div>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">

      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/love" target="_blank">
          
          <i class="fas fa-heart" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Love</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="../medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/medias/huowy.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">Huowy&#39;Blog</div>
        <div class="logo-desc">
            
            Huowy&#39;Blog
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友链
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-user-circle"></i>
			
			关于
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/love " style="margin-left:75px">
				  
				   <i class="fa fas fa-heart" style="position: absolute;left:50px" ></i>
			      
		          <span>Love</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/CarefulHuo" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/CarefulHuo" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>


    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/medias/featureimages/8.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">ConcurrentHashMap 源码阅读</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Map/">
                                <span class="chip bg-color">Map</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java/" class="post-category">
                                Java
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-05-26
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    16.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    64 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p><a target="_blank" rel="noopener" href="https://gentryhuang.com/posts/218dc61f/">源自 Gentryhuang 大佬</a>，感谢大佬的帮助！！！万分感谢！！！</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HashMap 不是线程安全的，在高并发环境下可能会出现系列问题，如链表成环（JDK1.7)、数据覆盖（JDK1.8)。想要避免 HashMap 的线程安全问题有很多办法，比如改用 HashTable 或者使用 Collections.synchronizedMap() 将 HashMap 包装成线程安全的。虽然这两种方法能解决线程安全问题，但是性能成了一个问题，无论读写操作都会给整个集合加锁，导致同一时间的其他操作阻塞。这个时候 ConcurrentHashMap 就应运而生了，它是基于 HashMap 实现的线程安全的集合。</p>
<p>考虑到 ConcurrentHashMap 在 JDK 不同的版本中实现差异较大，我们先对 JDK 1.7 版本进行简单介绍，然后重点介绍 JDK 1.8 版本中的实现。</p>
<h1 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h1><p>JDK 1.7 对 ConcurrentHashMap 的实现关键是：<strong>HashMap + Segment</strong>。哈希项的结构如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 哈希桶数组</span>
<span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> V value<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>HashEntry 的成员变量 value 和 next 是被关键字 volatile 修饰的，也就是说所有线程都可以及时检查到其他线程对这两个变量的改变，因此可以在不加锁的情况下读取到这两个引用的最新值。</p>
<p>Segment 通过继承 ReentrantLock 来进行加锁，通过每次锁住一个 Segment 来降低锁的粒度并保证了每个 Segment 内操作的线程安全性，从而实现全局线程安全。Segment 本身就相当于一个 HashMap 对象，每个 Segment 包含一个 HashEntry 数组。整个 ConcurrentHashMap 的结构如下：</p>
<p><img src="../medias/loading.gif" data-original="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-1.png"></p>
<p>可以看到，ConcurrentHashMap 是一个二级哈希表，桶数组是 Segment 数组，数组中的每个元素对应一个 HashMap 。</p>
<p>ConcurrentHashMap 设计成二级哈希表的目的就是采用<strong>锁分段技术</strong>提高并发度，每个 Segment 各自持有一把锁，Segment 之间互不影响。在保证线程安全的同时降低了锁的粒度，使并发操作效率更高。下面看看 ConcurrentHashMap 并发读写的几种情况：</p>
<ul>
<li>不同 Segment 的并发写入<br><img src="../medias/loading.gif" data-original="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-2.png"><br> 不同 Segment 的写入是可以并发执行的，因为每个 Segment 持有的锁不是同一个。</li>
<li>同一个 Segment 的并发读写<br><img src="../medias/loading.gif" data-original="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-3.png"><br> 同一个 Segment 的读写可以并发执行。</li>
<li>同一个 Segment 的并发写入<br><img src="../medias/loading.gif" data-original="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-4.png"><br> Segment 的写入是需要上锁的，因此对同一个 Segment 的并发写入会被阻塞。</li>
</ul>
<p>了解了 ConcurrentHashMap 并发读写的情况后，下面我们对常见的几个方法的执行流程简单说明。</p>
<h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><ol>
<li>对输入的 key 做 hash 运算得到 hash 值；</li>
<li>通过 hash 值对 Segment 数组定位对应的 Segment 对象；</li>
<li>再次通过 hash 值定位到 Segment 中数组的具体桶；</li>
</ol>
<p>可以看到，计算 key 的 hash 值后，<strong>要进行两次定位</strong>，第一次为了定位这个 key 是属于哪个 Segment；第二次为了定位这个 key 属于 Segment 中数组哪个桶；</p>
<h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><ol>
<li>对输入的 key 做 hash 运算得到 hash 值；</li>
<li>通过 hash 值对 Segment 数组定位对应的 Segment 对象；</li>
<li>获取 Segment 对应的可重入锁；</li>
<li>再次通过 hash 值定位到 Segment 中数组的具体桶；</li>
<li>插入或覆盖 HashEntry 对象；</li>
<li>释放可重入锁；</li>
</ol>
<h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>size 方法是统计 ConcurrentHashMap 中的元素数量，需要把各个 Segment 内的元素数量汇总起来。</p>
<ol>
<li>遍历所有的 Segment；</li>
<li>把 Segment 的元素数量累加起来；</li>
<li>把 Segment 的修改次数累加起来；</li>
<li>判断所有 Segment 的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。</li>
<li>如果尝试次数超过阈值，则对每一个 Segment 加锁，再重新统计。</li>
<li>判断所有 Segment 的总修改次数是否大于上一次的总修改次数，由于已经加锁，次数一定和上次相等。</li>
<li>依次释放 Segment 锁，统计结束；</li>
</ol>
<p><strong>说明：</strong>这里的 size 方法的思想有点类似乐观锁和悲观锁。为了尽量不锁住 Segment ，先乐观地统计元素数量，当尝试一定次数后仍然失败才会加锁统计。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ConcurrentHashMap 的结构图如下：</p>
<p><img src="../medias/loading.gif" data-original="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-5.png"></p>
<br>

<ul>
<li>ConcurrentHashMap 是线程安全的，其读取不需要加锁，通过引入 Segment 将写锁粒度缩小，每个 Segment 中的桶数组就相当于 HashTable；</li>
<li>由于引入了 Segment ，在读取和写入的时候需要做两次映射定位，第一次定位 Segment，第二次定位 Segment 中数组的桶；</li>
<li>到了第二次定位桶的过程，就和 HashMap 是一致的了；</li>
</ul>
<h1 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h1><p>相比 JDK 1.7 使用的 Segment 保证线程安全，JDK 1.8 进行了重写式优化，<strong>取消了 Segment 的设计，取而代之的是通过 CAS 操作和 synchronized 关键字来实现线程安全</strong>。当然，在存储结构上仍然基于 HashMap 。</p>
<p>ConcurrentHashMap 主要 UML 类图如下：</p>
<p><img src="../medias/loading.gif" data-original="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-6.png"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>写到这里，脑海里又响起了一阵声音，为什么要研究 ConcurrentHashMap 源码？我始终认为知其然知其所以然，才能算得上真正了解一个事物。在分析源码之前，我们以问题的方式进行驱动。</p>
<ul>
<li>ConcurrentHashMap 是怎么保证线程安全的？如，初始化时怎么保证安全、扩容时怎么保证安全、如何安全地执行读写操作、如何安全获取元素个数。</li>
<li>ConcurrentHashMap 并发效率是如何提高的？怎么控制并发的。</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/* ---------------- Constants -------------- */</span>
    <span class="token comment" spellcheck="true">/**
     * 最大容量，当两个构造函数中任何一个带参数的函数隐式指定较大的值时使用
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 默认容量大小 16，大小必须是 2^N
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 桶的树化阈值
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 桶的链表还原阈值
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 最小树化容量阈值：使用红黑树时最小的表容量。当 HashMap 中的容量 >= 该值时，才允许树形化链表即将链表转成红黑树
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * sizeCtl 中用于生成标记的位数。
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> RESIZE_STAMP_BITS <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 可以帮助调整大小的最大线程数。
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_RESIZERS <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">32</span> <span class="token operator">-</span> RESIZE_STAMP_BITS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 在 sizeCtl 中记录大小标记的位移，为 16
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RESIZE_STAMP_SHIFT <span class="token operator">=</span> <span class="token number">32</span> <span class="token operator">-</span> RESIZE_STAMP_BITS<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/*
     * 节点中的 hash 
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MOVED <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  ForwardingNode 类型节点的 hash 值</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEBIN <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 红黑树的根节点的 hash 值</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RESERVED <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hash for transient reservations</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> HASH_BITS <span class="token operator">=</span> <span class="token number">0x7fffffff</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 普通节点哈希的可用位</span>

    <span class="token comment" spellcheck="true">/**
     * CPU 的数量，以限制某些大小
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NCPU <span class="token operator">=</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* ---------------- Fields -------------- */</span>

    <span class="token comment" spellcheck="true">/**
     * 存储数据的 Node 数组，长度是 2 的幂
     *
     * 使用 volatile 来保证每次获取到的都是最新的值
     */</span>
    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 下一个要使用的表；仅在调整大小时为非空。
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTable<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 基本计数器值，主要在没有争用时使用
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> baseCount<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 多个含义，要重点理解
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> sizeCtl<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 调整大小时要拆分的下一个表索引（加一个）。
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> transferIndex<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 调整大小和/或创建 CounterCell 时使用自旋锁（通过 CAS 锁定）。
     * 0：不 busy  1：busy
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> cellsBusy<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 计数单元桶。当非空时，大小是 2 的幂。
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> CounterCell<span class="token punctuation">[</span><span class="token punctuation">]</span> counterCells<span class="token punctuation">;</span>
</code></pre>
<p>ConcurrentHashMap 中的属性比较多，属于 HashMap 中的属性就不再说明，下面对核心属性进行说明。</p>
<p><strong>MOVED:</strong> ForwardingNode 类型节点的 hash 值，在数组扩容的过程中如果旧数组的某个桶元素为空或者迁移完毕就会使用 ForwardingNode 对象填充，作为一个标记；<br><strong>baseCount:</strong> 记录元素个数的基本计数器，主要在没有竞争的情况下使用；<br><strong>counterCells:</strong> 元素个数的计数单元桶，在并发环境下将元素个数的记录分摊到不同的计数器上，缓解单个计数器的竞争；<br><strong>cellsBusy:</strong> 调整或创建计数单元 CounterCell 时的标记，表示某个线程竞争成功；</p>
<h4 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h4><p>sizeCtl 这个属性非常重要，对理解整个 ConcurrentHashMap 至关重要。</p>
<ol>
<li>正常情况下，sizeCtl 存储的是扩容阈值，固定为数组容量的 0.75 倍，默认值为 0；</li>
<li>当初始化数组时，sizeCtl 会被设置为 -1，表示某个线程抢到了初始化数组的资格，没有抢到资格的线程自旋以等待数组初始化完成。数组初始化完成后，会把 sizeCtl 设置为扩容的阈值；</li>
<li>当数组达到扩容条件时，sizeCtl 不再存储扩容阈值，而是用来标识正处于扩容过程。在扩容前，会将 sizeCtl 设置为一个负数，在扩容完成后会重新计算扩容阈值并赋值到 sizeCtl 。</li>
</ol>
<p>其中，扩容过程中 sizeCtl 为负数的情况不太好理解，下面我们详细说说这种情况下的 sizeCtl 为负数时的组成。假设场景为某时刻数组的容量为 16 ，此时达到了扩容的条件。</p>
<p><strong>第一步：</strong>扩容前先标识数组处于扩容的过程，即设置 sizeCtl 的值；</p>
<p>线程通过执行 <code>U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</code> 代码片段设置 sizeCtl 的值，因为此时数组容量为 16，针对该容量扩容的标识值 rs=32795（计算出来的），对应的二进制数为：<code>1000 0000 0001 1011 0000 0000 0000 0010</code> ，具体组成如下图：</p>
<p><img src="../medias/loading.gif" data-original="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-7.png"></p>
<p><strong>第二步：</strong>一旦扩容开始了，执行写操作（新增、删除）的线程<strong>发现</strong>集合处于扩容过程，此时就会加入到迁移元素的流程中，加快扩容进度；其中“发现”的情况如下：</p>
<ul>
<li>线程在新增元素后，如果判断达到扩容条件，那么会进入到扩容流程，如果此时已经有线程在扩容了，那么当前线程会加入到迁移元素的流程；</li>
<li>线程在定位数组桶时，发现桶中元素类型是 ForwardingNode ，那么会先加入到迁移元素流程，完成迁移后再执行写操作；</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**
     * 使用默认初始表大小 (16) 创建一个新的空映射。
     */</span>
    <span class="token keyword">public</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * Creates a new, empty map with an initial table size
     * accommodating the specified number of elements without the need
     * to dynamically resize.
     * 创建一个新的空映射，其初始表大小可容纳指定数量的元素，无需动态调整大小。
     *
     * @param initialCapacity The implementation performs internal
     *                        sizing to accommodate this many elements.
     * @throws IllegalArgumentException if the initial capacity of
     *                                  elements is negative
     */</span>
    <span class="token keyword">public</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 根据传入容量大小计算容量，返回大于 initialCapacity 且最近的2的整数次幂的数</span>
        <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>initialCapacity <span class="token operator">>=</span> <span class="token punctuation">(</span>MAXIMUM_CAPACITY <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                MAXIMUM_CAPACITY <span class="token operator">:</span>
                <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 将容量大小赋值给 sizeCtl，初始化后 sizeCtl 作为扩容阈值</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sizeCtl <span class="token operator">=</span> cap<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>初始化 ConcurrentHashMap 时底层数组是没有进行初始化的，会等到第一次添加元素时才会初始化。此外，相比 HashMap 控制数组容量及填充度分别使用了 <code>threshold</code> 和 <code>loadFactor</code>，ConcurrentHashMap 使用了 sizeCtl 属性来控制，具体如下：</p>
<ul>
<li>非扩容的情况下，sizeCtl 表示的语意同 threshold；</li>
<li>在计算扩容阈值时，使用了固定的负载因子 0.75；</li>
</ul>
<p>这个在后续的源码中会有体现。</p>
<h3 id="put-新增元素"><a href="#put-新增元素" class="headerlink" title="put() - 新增元素"></a>put() - 新增元素</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**
     * key 和 value，都不允许为 null
     */</span>
    <span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 默认覆盖式</span>
        <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>可以看到，使用 put 方法默认式覆盖式新增元素。</p>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**
     * 整体流程和 HashMap 类似
     *
     * @param key          key
     * @param value        value
     * @param onlyIfAbsent 是否覆盖
     * @return
     */</span>
    <span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// key 、value 都不允许为空</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null <span class="token operator">||</span> value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 得到 hash 值</span>
        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 用于记录要插入的元素所在桶的元素个数，主要用于判断是否将链表转为红黑树的情况</span>
        <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 自旋，结合 CAS 使用（如果 CAS 失败，则会重新取整个桶进行下面的流程），直到 put 操作完成后退出循环</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> f<span class="token punctuation">;</span>
            <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">//  1 如果数组为空，则进行数组初始化</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token comment" spellcheck="true">// 初始化数组</span>
                tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 2 定位到 hash 值对应的数组下标，得到第一个节点 f</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>

                <span class="token comment" spellcheck="true">// 如果数组该位置没有节点，则使用一次 CAS 操作将这个新值放入其中即可。</span>
                <span class="token comment" spellcheck="true">// 如果 CAS 失败，说明是并发操作，进入到下一个循环重试；如果 CAS 成功，则 break ，流程结束</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span>
                        <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token comment" spellcheck="true">// 插入成功，退出循环</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// no lock when adding to empty bin</span>
            <span class="token punctuation">}</span>

            <span class="token comment" spellcheck="true">// 3 如果 hash 值对应的位置有节点，且取的第一个节点的 hash 值为 MOVED ，说明当前数组处于扩容过程，则当前线程帮忙一起迁移元素，</span>
            <span class="token comment" spellcheck="true">// 然后再执行插入元素操作</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>
                <span class="token comment" spellcheck="true">// 辅助数据迁移</span>
                tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 4 非以上三种情况，也就是当前定位的桶不为空，且不在迁移元素，那么锁住这个桶（以桶的第一个元素作为锁对象-分段锁）</span>
                <span class="token comment" spellcheck="true">// 要插入的元素在该桶，则替换值（onlyIfAbsent=false）；不在该桶，则插入到链表结尾或插入树中；</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>

                V oldVal <span class="token operator">=</span> null<span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 4.1 获取 synchronized 的锁</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 再次检测第一个元素是否有变化，如果有变化则进入下一次循环，从头来过</span>
                    <span class="token comment" spellcheck="true">// Unsafe 类的 volatile 式查看值，保证获取到的值都是最新的</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>

                        <span class="token comment" spellcheck="true">// 如果第一个元素的hash值大于等于0（说明不是在迁移，也不是树），那就是桶中的元素使用的是链表方式存储</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token comment" spellcheck="true">// 记录链表的元素个数</span>
                            binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

                            <span class="token comment" spellcheck="true">// 遍历链表，尾节点插入数据</span>
                            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                K ek<span class="token punctuation">;</span>
                                <span class="token comment" spellcheck="true">// 如果发现了相同的 key ，判断是否要进行值覆盖，然后也就可以 break 了</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                                        <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>
                                                <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                    oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>

                                    <span class="token comment" spellcheck="true">// 找到了相同 key 的元素，根据情况进行覆盖并退出循环</span>
                                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                                        e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>

                                <span class="token comment" spellcheck="true">// 到了链表的末尾还没发现相同 key 的元素，那么就将这个新值放到链表的最后，尾插法</span>
                                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                    pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>
                                            value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                        <span class="token comment" spellcheck="true">// 树结构</span>
                        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> p<span class="token punctuation">;</span>
                            <span class="token comment" spellcheck="true">// 记录树中元素个数为 2「注意，树的情况没有进行累加」</span>
                            binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                            <span class="token comment" spellcheck="true">// 调用红黑树的插入方法插入元素，如果成功则返回 null，否则返回找到的节点</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">)</span> f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>
                                    value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>

                                <span class="token comment" spellcheck="true">// 找到了相同 key 的元素，根据情况进行覆盖并退出循环</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                                    p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">// 如果 binCount不为0，说明成功插入了元素或者寻找到了元素</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 如果链表元素个数 >= 8 ，那么尝试进行链表树化「只有数组容量 >= 64 时才会真正进行树化，否则优先扩容」</span>
                    <span class="token comment" spellcheck="true">// 因为上面把元素插入到树中时，binCount只赋值了2，并没有计算整个树中元素的个数，所以不会重复树化</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD<span class="token punctuation">)</span>
                        <span class="token comment" spellcheck="true">// 树化</span>
                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// 如果要插入的元素已经存在，那么把旧值返回</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                        <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// 退出外层大循环，流程结束</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 如果是插入元素的情况，则：累加元素个数 &amp; 判断扩容</span>
        <span class="token function">addCount</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 成功插入元素返回 null</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>从上述新增元素的源码中可以看到，如果将并发控制的逻辑剔除，剩下的逻辑和 HashMap 的 put 方法基本类似。主干流程如下：</p>
<ol>
<li>不允许 key 或 value 为 null；</li>
<li>如果桶数组未初始化，执行初始化流程，然后再尝试添加元素；</li>
<li>如果待插入的元素所在的桶为空，则使用 CAS 尝试将元素放到该桶中；</li>
<li>如果数组正处于扩容过程，那么当前线程一起加入到扩容的过程中；</li>
<li>如果待插入的元素所在的桶不为空，且没有迁移元素，那么锁住这个桶，锁粒度就是桶元素对象；<ul>
<li>如果当前桶中元素以链表方式存储，则在链表中寻找该元素或者<strong>尾插入元素</strong>；</li>
<li>如果当前桶中元素以红黑树方式存储，则在红黑树中寻找该元素或者插入元素；</li>
</ul>
</li>
<li>针对链表的情况判断是否需要进行树化；</li>
<li>如果要插入的元素（元素 key）存在，则返回旧值，此时不需要累加元素个数以及判断容量情况；</li>
<li>如果要插入的元素（元素 key）不存在，则累加元素个数，并检查是否需要扩容；</li>
</ol>
<p>了解了添加元素的主干逻辑后，<strong>下面我们对上述方法中针对并发控制的关键点进行说明</strong>：</p>
<ul>
<li>使用<strong>自旋结合CAS的方式</strong>完成新增元素操作；</li>
<li>使用<strong>Unsafe 类的 volatile 式的获取方法查看元素，保证每次获取到的元素都是最新的</strong>。注意，虽然桶数组 table 使用了 volatile 修饰，但也只能保证其引用的可见性，并不能确保其数组中的元素是否是最新的，所以通过 Unsafe 类的 volatile 式获取到最新的元素；</li>
<li>协同扩容流程优先，新增元素流程靠后；</li>
<li>使用 <code>synchronized</code> 实现分段锁，完成新增元素的流程。注意，这里将 key 映射的桶元素作为锁对象，达到缩小锁范围的目的。在 hash 不冲突的情况下，可同时支持 n 个线程同时 put 操作，n 为桶数组的大小。</li>
</ul>
<h3 id="initTable-初始化数组"><a href="#initTable-初始化数组" class="headerlink" title="initTable() - 初始化数组"></a>initTable() - 初始化数组</h3><p>初始化数组流程是在新增元素时进行的，通过对新增元素的源码分析后我们知道，初始化数组流程是不受锁的保护的，那么该方法是如何处理并发问题的呢？下面我们一起来看看源码是如何实现的。</p>
<pre class=" language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>
        <span class="token keyword">int</span> sc<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 每次循环都获取最新的 Node 数组引用</span>
        <span class="token comment" spellcheck="true">// 初始化数组时，sizeCtl 为数组容量大小，默认为 0；如果 sizeClt > 0 ，那使用的是带有初始化容量的构造方法</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token comment" spellcheck="true">// 如果 sizeCtl &lt; 0 ，说明其它线程正在进行初始化或扩容，那么就让出 CPU，从运行状态回到就绪状态</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lost initialization race; just spin 初始化失败，只是旋转</span>

                <span class="token comment" spellcheck="true">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了初始化数组的资格，当前线程进入初始化，成功后退出循环。</span>
                <span class="token comment" spellcheck="true">// 如果原子更新失败则说明有其它线程先一步进入初始化了，则进入下一次循环，如果下一次循环时还没初始化完毕，则sizeCtl&lt;0进入上面if的逻辑让出CPU，如果初始化完毕退出循环；</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>

                    <span class="token comment" spellcheck="true">// 再次检查table是否为空</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                        <span class="token comment" spellcheck="true">// 如果 sc 为 0，则使用 DEFAULT_CAPACITY 默认初始容量是 16</span>
                        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>

                        <span class="token comment" spellcheck="true">// 创建数组，长度为 16 或初始化时提供的长度（也是 2^N)</span>
                        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>

                        <span class="token comment" spellcheck="true">// 将创建的数组赋值给 table</span>
                        table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>

                        <span class="token comment" spellcheck="true">// 设置 sc 为数组长度的 0.75 倍</span>
                        <span class="token comment" spellcheck="true">// n - (n >>> 2) = n - n/4 = 0.75 * n</span>
                        sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>

                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 由于这里只会有一个线程在执行，直接赋值即可，没有线程安全问题。把sc赋值给sizeCtl，这时存储的是扩容阈值</span>
                    sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> tab<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>初始化数组的主要过程如下：</p>
<ol>
<li>使用 CAS 设置 sizeCtl 为 -1 ，控制只有一个线程初始化桶数组，CAS 失败的线程会等待桶数组初始化完毕；</li>
<li>sizeCtl 在初始化后存储的是桶数组的扩容阈值，其中扩容阈值的计算是固定的，大小为<strong>桶数组大小的 0.75 倍</strong>。这里的负载因子和扩容阈值相当于都是固定了，这也正是没有使用 threshold 和 loadFactor 属性而是使用 sizeCtl 控制数组的原因。</li>
</ol>
<p>可见，就算有多个线程同时进行 put 操作，在初始化数组时使用了乐观锁 CAS 操作来决定哪个线程有资格进行初始化，其它线程只能等待数组初始化完成。处理并发点如下：</p>
<ul>
<li>桶数组 table 使用了 volatile 修饰，保证获取到的都是最新的值；</li>
<li>数组控制 sizeCtl 属性使用了 volatile 修饰，保证线程间的可见性；</li>
<li>使用 CAS 操作保证设置 sizeCtl 标记的原子性，只有一个线程能设置成功，没有设置成功的线程，等待数组初始化完成即可；</li>
</ul>
<h3 id="addCount-计数并判断扩容"><a href="#addCount-计数并判断扩容" class="headerlink" title="addCount() - 计数并判断扩容"></a>addCount() - 计数并判断扩容</h3><p>每次添加元素后（注意，是添加不是覆盖），集合中的元素数需要加 1，然后判断是否达到扩容阈值，达到了需要进行扩容或协助迁移元素。</p>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/** 
     * @param x     要累加的数量
     * @param check 如果&lt;0，不检查调整大小；如果&lt;= 1，只检查是否无竞争；
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> check<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">/*----------------------- 1、累加元素个数  ---------------------------*/</span>

        <span class="token comment" spellcheck="true">// 这里使用的思想和 LongAdder 类很类似。</span>
        CounterCell<span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span>
        <span class="token keyword">long</span> b<span class="token punctuation">,</span> s<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 统计元素个数的操作</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> counterCells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">||</span>
                <span class="token operator">!</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> BASECOUNT<span class="token punctuation">,</span> b <span class="token operator">=</span> baseCount<span class="token punctuation">,</span> s <span class="token operator">=</span> b <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token comment" spellcheck="true">/* 执行到这里，说明：
            1.counterCells被初始化完成了，不为null
            2.增加数量到 baseCount 失败了，存在线程竞争，接下来尝试增加到当前线程映射到的桶上
            3.先优先尝试把数量加到 baseCount 上，如果失败再加到对应的 CounterCell 上
            */</span>
            CounterCell a<span class="token punctuation">;</span>
            <span class="token keyword">long</span> v<span class="token punctuation">;</span>
            <span class="token keyword">int</span> m<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">//标志是否存在竞争</span>
            <span class="token keyword">boolean</span> uncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 在计数桶数组中随机选一个计数桶，然后使用CAS操作将此计数桶中的value+1</span>
            <span class="token comment" spellcheck="true">// 1 先判断计数桶是否还没初始化，也就是 as==nul，进入语句</span>
            <span class="token comment" spellcheck="true">// 2 判断计数桶长度是否为空或，若是进入语句块</span>
            <span class="token comment" spellcheck="true">// 3 这里做了一个线程变量随机数，与上桶大小-1，若桶的这个位置为空，进入语句块</span>
            <span class="token comment" spellcheck="true">// 4 到这里说明桶已经初始化了，且随机的这个位置不为空，尝试CAS操作使桶加1，失败进入语句块</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> as<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
                    <span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span>ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span>
                    <span class="token operator">!</span><span class="token punctuation">(</span>uncontended <span class="token operator">=</span>
                            U<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> CELLVALUE<span class="token punctuation">,</span> v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                <span class="token comment" spellcheck="true">// 若CAS操作失败，证明有竞争，进入fullAddCount方法</span>
                <span class="token comment" spellcheck="true">// 失败几次，那么就对counterCells进行扩容，以减少多个线程hash到同一个桶的概率</span>
                <span class="token function">fullAddCount</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> uncontended<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 返回</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 计算元素个数</span>
            s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">/*------------------ 2、判断是否需要进行扩容 ----------------*/</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> nt<span class="token punctuation">;</span>
            <span class="token keyword">int</span> n<span class="token punctuation">,</span> sc<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 如果元素个数达到了扩容阈值，则进行扩容。</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>

                <span class="token comment" spellcheck="true">// rs 为要扩容容量为 n 的数组的一个标识，如数组容量 n=16，那 rs=32795</span>
                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// sc &lt; 0 说明有线程正在迁移</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>sc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                    <span class="token comment" spellcheck="true">//  判断扩容是否已经完成了，如果完成则退出循环</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">>>></span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">!=</span> rs <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span>
                            sc <span class="token operator">==</span> rs <span class="token operator">+</span> MAX_RESIZERS <span class="token operator">||</span> <span class="token punctuation">(</span>nt <span class="token operator">=</span> nextTable<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span>
                            transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// 扩容未完成，则当前线程加入迁移元素流程中，并把扩容线程数加 1</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nt<span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// 不为负数，则为第一个迁移的线程，此时多了创建新数组的操作</span>
                    <span class="token comment" spellcheck="true">// sizeCtl 的高 16 位存储 rs 这个标识</span>
                    <span class="token comment" spellcheck="true">// sizeCtl 的低 16 位存储扩容线程数，刚开始为2，表示有一个线程正在迁移，如果为3，代表2个线程正在迁移以此类推…</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

                    <span class="token comment" spellcheck="true">// 进入扩容并迁移元素的逻辑，传入 nextTab 为 null 就会触发创建新数组进而扩容</span>
                    <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 重新计算元素个数</span>
                s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>从上面的源码中也可以看到，上述方法包含两部分的逻辑，一个是记录集合中元素个数，另一个是达到扩容阈值执行扩容逻辑。下面我们分别介绍。</p>
<h4 id="记数"><a href="#记数" class="headerlink" title="记数"></a>记数</h4><p>在 ConcurrentHashMap 中，快速统计元素个数是非常重要的，不仅使用方会关注集合中元素个数，而且集合内部需要根据元素个数来判断是否需要扩容。使用的思想和 LongAdder 类似，如下图：</p>
<p><img src="../medias/loading.gif" data-original="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-8.png"></p>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**
     * 桶是由线程对应的，多个线程可以对应一个桶
     */</span>
    <span class="token annotation punctuation">@sun</span><span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Contended
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">CounterCell</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/**
         * 当前桶对应的元素数量，可见性保证
         */</span>
        <span class="token keyword">volatile</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span>

        <span class="token function">CounterCell</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            value <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>在设计时，使用了<strong>分而治之</strong>的思想，除了基础的计数，将每一个计数都分散到各个 CounterCell 对象（桶）中，使竞争最小化。总的来说，ConcurrentHashMap 的大小分为两部分：</p>
<ul>
<li>基础计数 baseCount: 在记录元素个数时优先 CAS 更新该属性，如果 CAS 失败才会采用分治桶计数的方式。即在线程竞争不大的时候，直接使用CAS操作baseCount值即可；</li>
<li>分治桶计数 CounterCell[]: 若出现了CAS操作失败的情况，则证明此时有线程竞争了，计数方式转变为分而治之的桶计数方式，也就是线程映射到不同的 CounterCell；</li>
</ul>
<p>了解了 ConcurrentHashMap 计数的思想后，下面看看源码是如何实现的。</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> check<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">/*----------------------- 1、累加元素个数  ---------------------------*/</span>
        CounterCell<span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span>
        <span class="token keyword">long</span> b<span class="token punctuation">,</span> s<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 统计元素个数的操作</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> counterCells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">||</span>
                <span class="token operator">!</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> BASECOUNT<span class="token punctuation">,</span> b <span class="token operator">=</span> baseCount<span class="token punctuation">,</span> s <span class="token operator">=</span> b <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token comment" spellcheck="true">/*------------- 执行到这里，说明：
            1.counterCells被初始化完成了，不为null
            2.增加数量到 baseCount 失败了，存在线程竞争，接下来尝试增加到当前线程映射到的桶上
            3.先优先尝试把数量加到 baseCount 上，如果失败再加到对应的 CounterCell 上
            ----------------*/</span>
            CounterCell a<span class="token punctuation">;</span>
            <span class="token keyword">long</span> v<span class="token punctuation">;</span>
            <span class="token keyword">int</span> m<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">//标志是否存在竞争</span>
            <span class="token keyword">boolean</span> uncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 在计数桶数组中根据当前线程选一个计数桶，然后使用CAS操作将此计数桶中的value+1</span>
            <span class="token comment" spellcheck="true">// 1 先判断计数桶是否还没初始化，也就是 as==nul，进入语句</span>
            <span class="token comment" spellcheck="true">// 2 判断计数桶长度是否为空或，若是进入语句块</span>
            <span class="token comment" spellcheck="true">// 3 这里做了一个线程变量随机数，与上桶大小-1，若桶的这个位置为空，进入语句块</span>
            <span class="token comment" spellcheck="true">// 4 到这里说明桶已经初始化了，且随机的这个位置不为空，尝试CAS操作使桶加1，失败进入语句块</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> as<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
                    <span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span>ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span>
                    <span class="token operator">!</span><span class="token punctuation">(</span>uncontended <span class="token operator">=</span>
                            U<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> CELLVALUE<span class="token punctuation">,</span> v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                <span class="token comment" spellcheck="true">//若CAS操作失败，证明有竞争，进入fullAddCount方法</span>
                <span class="token comment" spellcheck="true">// 失败几次，那么就对counterCells进行扩容，以减少多个线程hash到同一个桶的概率</span>
                <span class="token function">fullAddCount</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> uncontended<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 返回</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 计算元素个数</span>
            s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">//... 省略判断扩容逻辑</span>
  <span class="token punctuation">}</span>
</code></pre>
<p>从源码中也能看到，在计数时优先使用基础计数，有竞争的情况下会使用<strong>分而治之桶计数</strong>，对应的逻辑在 <code>fullAddCount</code> 方法中。这里有两种情况，一种是计数桶数组还没有初始化，另外一种是计数数组已经初始化过了，此外，<strong>如果计数桶数组存在，优先使用分而治之桶计数</strong>。下面我们从源码层面看这两种情况。</p>
<h5 id="初始化计数桶数组"><a href="#初始化计数桶数组" class="headerlink" title="初始化计数桶数组"></a>初始化计数桶数组</h5><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">// See LongAdder version for explanation</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">fullAddCount</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">boolean</span> wasUncontended<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 线程对应的随机值</span>
        <span class="token keyword">int</span> h<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">localInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// force initialization</span>
            h <span class="token operator">=</span> ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">boolean</span> collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// True if last slot nonempty</span>

        <span class="token comment" spellcheck="true">// 自旋，更新元素个数</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            CounterCell<span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span>
            CounterCell a<span class="token punctuation">;</span>
            <span class="token keyword">int</span> n<span class="token punctuation">;</span>
            <span class="token keyword">long</span> v<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 如果计数单元桶!=null，证明已经初始化过，那么就针对当前线程映射一个计算单元并累加数量</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> counterCells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> as<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                 <span class="token comment" spellcheck="true">//... 略</span>

                <span class="token comment" spellcheck="true">// 进入此语句块进行计数桶的初始化</span>
                <span class="token comment" spellcheck="true">// CAS设置cellsBusy=1，表示现在计数桶 busy 中，控制并发</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> counterCells <span class="token operator">==</span> as <span class="token operator">&amp;&amp;</span>
                    U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> CELLSBUSY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                <span class="token comment" spellcheck="true">// 若有线程同时初始化计数桶，由于CAS操作只有一个线程进入这里</span>
                <span class="token keyword">boolean</span> init <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

                <span class="token keyword">try</span> <span class="token punctuation">{</span>

                    <span class="token comment" spellcheck="true">//再次确认计数桶为空</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>counterCells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment" spellcheck="true">//初始化一个长度为2的计数桶</span>
                        CounterCell<span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterCell</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                        <span class="token comment" spellcheck="true">//h为当前线程相关的一个随机数，&amp; 1 代表，在 0、1中随机的一个</span>
                        <span class="token comment" spellcheck="true">//也就是在0、1下标中随便选一个计数桶，x=1，放入1的值代表增加1个容量</span>
                        rs<span class="token punctuation">[</span>h <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterCell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment" spellcheck="true">//将初始化好的计数桶赋值给ConcurrentHashMap中的属性</span>
                        counterCells <span class="token operator">=</span> rs<span class="token punctuation">;</span>
                        init <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">//最后将busy标识设置为0，表示不busy了</span>
                    cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">// 初始化计数桶数组后退出循环</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>init<span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">//若有线程同时来初始化计数桶，则没有抢到busy资格的线程就CAS递增基础计数 baseCount</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> BASECOUNT<span class="token punctuation">,</span> v <span class="token operator">=</span> baseCount<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">// Fall back on using base</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>可以看到，当更新基础计数器 baseCount 失败后，获取到初始化资格的线程会初始化一个大小为 2 的计算桶数组。<strong>完成了计数桶数组的初始化后，在之后的计数都将会使用计算桶来计数</strong>。</p>
<p><strong>注意：</strong>这里同样使用了 CAS 保证并发安全，如果在初始化时，有并发竞争，那么竞争失败的线程会 CAS 更新基础计数器 baseCount，尽可能提高并发度。</p>
<h5 id="扩容计数桶"><a href="#扩容计数桶" class="headerlink" title="扩容计数桶"></a>扩容计数桶</h5><p>从上面初始化计数桶数组中我们知道，计数桶的长度为 2，在并发大的时候竞争依然会很大，因此就需要计数桶数组的扩容，这个过程就对应 fullAddCount 方法的另一个分支。</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">fullAddCount</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">boolean</span> wasUncontended<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 线程对应的随机值，用于对计数桶数组取模定位计算桶</span>
        <span class="token keyword">int</span> h<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">localInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// force initialization</span>
            h <span class="token operator">=</span> ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">boolean</span> collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// True if last slot nonempty</span>

        <span class="token comment" spellcheck="true">// 自旋，更新元素个数</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            CounterCell<span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span>
            CounterCell a<span class="token punctuation">;</span>
            <span class="token keyword">int</span> n<span class="token punctuation">;</span>
            <span class="token keyword">long</span> v<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 如果计数单元桶!=null，证明已经初始化过，那么就针对当前线程映射一个计算桶并计算元素数</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> counterCells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> as<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                <span class="token comment" spellcheck="true">//从计数桶数组中定位当前线程映射的计数桶，若为null表示该桶为空，需要创建一个</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>

                    <span class="token comment" spellcheck="true">//判断计数单元 的 busy 状态（用于控制并发），为 0 表示不忙碌，即没有线程竞争</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Try to attach new Cell</span>

                        <span class="token comment" spellcheck="true">// 创建一个计数单元桶，初始值为传入的个数 x</span>
                        CounterCell r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterCell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Optimistic create</span>

                        <span class="token comment" spellcheck="true">// CAS 操作 busy 为 1，标记计数桶处理中</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
                                U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> CELLSBUSY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token keyword">boolean</span> created <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                            <span class="token keyword">try</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// Recheck under lock</span>
                                CounterCell<span class="token punctuation">[</span><span class="token punctuation">]</span> rs<span class="token punctuation">;</span>
                                <span class="token keyword">int</span> m<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
                                <span class="token comment" spellcheck="true">// 再检查一次计数桶为null</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rs <span class="token operator">=</span> counterCells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>
                                        <span class="token punctuation">(</span>m <span class="token operator">=</span> rs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
                                        rs<span class="token punctuation">[</span>j <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>

                                    <span class="token comment" spellcheck="true">//将刚刚创建的计数桶赋值给对应位置</span>
                                    rs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>
                                    created <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>
                            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                                <span class="token comment" spellcheck="true">// 处理完成后，标记计数桶处理完成</span>
                                cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>

                            <span class="token comment" spellcheck="true">// 如果是创建计数桶的情况，直接退出循环即可</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>created<span class="token punctuation">)</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>

                            <span class="token keyword">continue</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// Slot is now non-empty</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                    collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">/*------------- 走到这里，说明当前线程映射的计数桶不为空 ----------------*/</span>

                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wasUncontended<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">// CAS already known to fail</span>
                    wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// Continue after rehash</span>

                    <span class="token comment" spellcheck="true">//走到这里代表计数桶不为null，尝试递增计数桶</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> CELLVALUE<span class="token punctuation">,</span> v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>

                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>counterCells <span class="token operator">!=</span> as <span class="token operator">||</span> n <span class="token operator">>=</span> NCPU<span class="token punctuation">)</span>
                    collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// At max size or stale</span>

                    <span class="token comment" spellcheck="true">//若CAS操作失败了，到了这里，会先进入一次，然后再走一次刚刚的for循环</span>
                    <span class="token comment" spellcheck="true">//若是第二次for循环，collide=true，则不会走进去</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>collide<span class="token punctuation">)</span>
                    collide <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">/* 走到这里，说明竞争较大，多个线程都映射到了一个计数桶，导致更新计数失败较多，那么就需要通过扩容计数桶数组来减小竞争 */</span>
                    <span class="token comment" spellcheck="true">//一个线程若进行了多次CAS操作计数桶失败，那么就需要进行计数桶扩容逻辑，完成扩容后重新计数</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
                        U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> CELLSBUSY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token comment" spellcheck="true">// 确认计数桶还是同一个</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>counterCells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// Expand table unless stale</span>

                            <span class="token comment" spellcheck="true">//将长度扩大到2倍</span>
                            CounterCell<span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterCell</span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

                            <span class="token comment" spellcheck="true">// 遍历旧计数桶，直接将旧计数桶拿过来填充</span>
                            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
                                rs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                            counterCells <span class="token operator">=</span> rs<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>

                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                        <span class="token comment" spellcheck="true">// 完成扩容后，标记计数桶处理完成</span>
                        cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// Retry with expanded table</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">// 重新计算当前线程的随机值，用于定位对应的计数桶</span>
                h <span class="token operator">=</span> ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">advanceProbe</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 进入此语句块进行计数桶的初始化</span>
                <span class="token comment" spellcheck="true">// CAS设置cellsBusy=1，表示现在计数桶 busy 中</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> counterCells <span class="token operator">==</span> as <span class="token operator">&amp;&amp;</span>
                    U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> CELLSBUSY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                   <span class="token comment" spellcheck="true">//... 省略</span>

                <span class="token comment" spellcheck="true">//若有线程同时来初始化计数桶，则没有抢到busy资格的线程就先来CAS递增baseCount</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> BASECOUNT<span class="token punctuation">,</span> v <span class="token operator">=</span> baseCount<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">// Fall back on using base</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>在 CAS 操作计数桶失败多次之后，会先进行扩容计数桶数组流程，扩容完毕后再次尝试 CAS 操作映射的计数桶。一般扩容后再次 CAS 操作大都会成功，除非并发太大了。</p>
<h5 id="统计元素个数"><a href="#统计元素个数" class="headerlink" title="统计元素个数"></a>统计元素个数</h5><pre class=" language-java"><code class="language-java">    <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 计算所有计数桶及 baseCount 的数量之和</span>
        CounterCell<span class="token punctuation">[</span><span class="token punctuation">]</span> as <span class="token operator">=</span> counterCells<span class="token punctuation">;</span>
        CounterCell a<span class="token punctuation">;</span>
        <span class="token keyword">long</span> sum <span class="token operator">=</span> baseCount<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 遍历 CounterCell ，不保证可见性</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> as<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 使用 getObjectVolatile 方法保证可见性</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                    sum <span class="token operator">+=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>由于集合中的元素存储在两个部分中，因此需要将两部分的数量累加起来。</p>
<p><strong>注意：</strong>上述统计元素个数的方法是弱一致性的，因为在遍历 CounterCell 数组时，不能保证其内部属性 value 的可见性。</p>
<h5 id="计数小结"><a href="#计数小结" class="headerlink" title="计数小结"></a>计数小结</h5><p>计数时优先利用 CAS 操作基础计数器 baseCount，在竞争不大时一般都能成功，此时性能没有啥大的损失；</p>
<p>若存在线程竞争基础计数器 baseCount，则初始化计数桶数组来分摊竞争。在初始化计数桶数组的过程中也存在竞争的话，通过 CAS 保证只有一个线程有资格进行初始化，没有抢到初始化资格的线程直接尝试 CAS 操作基础计数器的方式完成计数，没有完成计数的线程会进行自旋，<strong>尽可能最大化并发度</strong>。</p>
<p>如果已经存在计数桶数组，那么使用计数桶计数，采用分而治之的方式来计数。由于计数桶数组能同时提供计数的桶数量有限，如果还是存在频繁失败的情况，那么就对计数桶数组扩容，并发安全的处理同样使用 CAS 来保证，这样就可以支持同时更多线程并发计数了。其中，在为线程映射计数桶时，<strong>利用位运算和随机数以负载均衡的方式将线程计数请求接近均匀的分散到不同的计数桶中</strong>。</p>
<h4 id="判断扩容"><a href="#判断扩容" class="headerlink" title="判断扩容"></a>判断扩容</h4><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/** because resizings are lagging additions.
     *
     * @param x     要累加的数量
     * @param check 如果&lt;0，不检查调整大小；如果&lt;= 1，只检查是否无竞争；
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> check<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">/*----------------------- 1、累加元素个数  ---------------------------*/</span>
        CounterCell<span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span>
        <span class="token keyword">long</span> b<span class="token punctuation">,</span> s<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//... 省略</span>

        <span class="token comment" spellcheck="true">// 计算元素个数</span>
        s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/*------------------ 2、判断是否需要进行扩容 ----------------*/</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> nt<span class="token punctuation">;</span>
            <span class="token keyword">int</span> n<span class="token punctuation">,</span> sc<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 如果元素个数达到了扩容阈值，则进行扩容。</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>

                <span class="token comment" spellcheck="true">// rs 为要扩容容量为 n 的数组的一个标识，如数组容量 n=16，那 rs=32795</span>
                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// sc &lt; 0 说明有线程正在迁移</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>sc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                    <span class="token comment" spellcheck="true">//  判断扩容是否已经完成了，如果完成则退出循环</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">>>></span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">!=</span> rs <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span>
                            sc <span class="token operator">==</span> rs <span class="token operator">+</span> MAX_RESIZERS <span class="token operator">||</span> <span class="token punctuation">(</span>nt <span class="token operator">=</span> nextTable<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span>
                            transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// 扩容未完成，则当前线程加入迁移数据流程中，并把扩容线程数加 1</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nt<span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// 不为负数，则为第一个迁移的线程，此时多了创建新数组的操作</span>
                    <span class="token comment" spellcheck="true">// sizeCtl 的高 16 位存储 rs 这个标识</span>
                    <span class="token comment" spellcheck="true">// sizeCtl 的低 16 位存储扩容线程数，刚开始为2，表示有一个线程正在迁移，如果为3，代表2个线程正在迁移以此类推…</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

                    <span class="token comment" spellcheck="true">// 进入扩容并迁移元素的逻辑，传入 nextTab 为 null 就会触发创建新数组进而扩容</span>
                    <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 重新计算元素个数</span>
                s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>每次添加元素后，集合中的元素数量加 1。紧接着会判断是否达到扩容阈值，达到的话则<strong>进行扩容或协助扩容</strong>。</p>
<p>如果达到扩容条件，那么会有一个线程 CAS 设置扩容标识位 sizeCtl 成功，此时 <strong>sizeCtl 的含义</strong>前文已经详细介绍。获取到扩容资格的线程会执行 <code>transfer(tab, null)</code> 方法进入扩容和迁移元素流程，启动扩容流程后进入上述方法的线程会感知到 <code>sizeCtl&lt;0</code> ，此时如果扩容还没有结束，也会加入到迁移元素的流程中，<strong>此时需要注意 sizeCtl 值的更新</strong>。 </p>
<h3 id="tryPresize-扩容或迁移元素"><a href="#tryPresize-扩容或迁移元素" class="headerlink" title="tryPresize() - 扩容或迁移元素"></a>tryPresize() - 扩容或迁移元素</h3><p>除了执行 put 方法时检测到达到扩容阈值会扩容，检测链表是否要进行树化的时候也需要判断可否优先扩容。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> b<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> sc<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 若数组长度小于64，则优先扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span>
      <span class="token comment" spellcheck="true">// 尝试扩容</span>
      <span class="token function">tryPresize</span><span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 转换为红黑树</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span>hash <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//...转换为红黑树的操作</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>treeifyBin 方法会将链表转换为红黑树以增加查找效率，但在这之前会检查数组长度，若小于 64 则会优先做扩容操作。其中尝试扩容的方法和前文中的 <code>addCount</code> 方法的判断是否扩容分支逻辑基本类似，就不再重复说明，源代码注释如下：</p>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**
     * 扩容
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">tryPresize</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 取 2^n 值</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> <span class="token punctuation">(</span>MAXIMUM_CAPACITY <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>size <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> sc<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 数组没有在初始化或扩容</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>
            <span class="token keyword">int</span> n<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 该分支用于初始化数组，主要用于 putAll 方法添加元素的场景</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> c<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> tab<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
                            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
                            table <span class="token operator">=</span> nt<span class="token punctuation">;</span>
                            sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                        sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token comment" spellcheck="true">// 无需进行扩容</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;=</span> sc <span class="token operator">||</span> n <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 进行扩容</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 扩容 table 的 epoch</span>
                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 如果处于扩容过程中</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>sc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt<span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">// 扩容完毕了，退出循环</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">>>></span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">!=</span> rs <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span>
                            sc <span class="token operator">==</span> rs <span class="token operator">+</span> MAX_RESIZERS <span class="token operator">||</span> <span class="token punctuation">(</span>nt <span class="token operator">=</span> nextTable<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span>
                            transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">//  CAS 将 sizeCtl 加 1 表示当前线程加入到扩容过程，然后执行 transfer 方法</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nt<span class="token punctuation">)</span><span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// CAS 设置 sizeCtl 成功后执行 transfer 方法进行扩容</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span>
                        <span class="token punctuation">(</span>rs <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<h3 id="transfer-扩容或迁移元素"><a href="#transfer-扩容或迁移元素" class="headerlink" title="transfer() - 扩容或迁移元素"></a>transfer() - 扩容或迁移元素</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**
     * @param tab     旧数组
     * @param nextTab 扩大2倍后的新数组，如果为空说明还没有创建新数组
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 记录旧数组容量</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">,</span> stride<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 根据机器CPU核心数来计算，一条线程负责Node数组中多长的迁移量， stride 就是当前线程分到的迁移量</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span>NCPU <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> NCPU <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TRANSFER_STRIDE<span class="token punctuation">)</span>
            stride <span class="token operator">=</span> MIN_TRANSFER_STRIDE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// subdivide range</span>


        <span class="token comment" spellcheck="true">/*--------------------------------- 1、扩容 -------------------------------------*/</span>

        <span class="token comment" spellcheck="true">// nextTab 为空，说明还没开始扩容，就创建一个新桶数组</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// initiating</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 新桶数组大小是原桶的 2 倍</span>
                <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                nextTab <span class="token operator">=</span> nt<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// try to cope with OOME</span>
                sizeCtl <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment" spellcheck="true">// 扩容期间的新数组</span>
            nextTable <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 旧数组容量作为迁移下标</span>
            transferIndex <span class="token operator">=</span> n<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>



        <span class="token comment" spellcheck="true">/*--------------------------------- 2、迁移元素 ---------------------------------*/</span>

        <span class="token comment" spellcheck="true">// 新数组大小</span>
        <span class="token keyword">int</span> nextn <span class="token operator">=</span> nextTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 新建一个 ForwardingNode 类型的标记节点，其 hash 值为 MOVED，并把新桶数组存储在里面，这个对象作为旧数组某个桶迁移完毕的标志。</span>
        ForwardingNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> fwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForwardingNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">(</span>nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">boolean</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> finishing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// to ensure sweep before committing nextTab</span>

        <span class="token comment" spellcheck="true">// 从后往前，依次对旧数组每个桶进行元素的迁移</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bound <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> f<span class="token punctuation">;</span>
            <span class="token keyword">int</span> fh<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 2.1 确定要迁移的桶的下标</span>
            <span class="token comment" spellcheck="true">// i 的值会从 n-1 依次递减，其中 n 是旧桶数组的大小。比如，i 从 15 开始一直减到 1 这样去迁移元素</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>advance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> nextIndex<span class="token punctuation">,</span> nextBound<span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// i为当前正在处理的Node数组下标，每次处理一个Node节点就会自减1</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>i <span class="token operator">>=</span> bound <span class="token operator">||</span> finishing<span class="token punctuation">)</span>
                    advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nextIndex <span class="token operator">=</span> transferIndex<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                    advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// CAS 下标，保证每个线程获取到正确的下标，支持并发迁移元素</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span>
                        <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> TRANSFERINDEX<span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span>
                                nextBound <span class="token operator">=</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">></span> stride <span class="token operator">?</span>
                                        nextIndex <span class="token operator">-</span> stride <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    bound <span class="token operator">=</span> nextBound<span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// 确定好小标后，就可以退出确定下标的循环了</span>
                    i <span class="token operator">=</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                    advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token comment" spellcheck="true">// 2.2 对下标为 i 的桶进行处理</span>

            <span class="token comment" spellcheck="true">// 如果旧数组元素迁移完了</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> n <span class="token operator">||</span> i <span class="token operator">+</span> n <span class="token operator">>=</span> nextn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> sc<span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 如果所有桶中的元素都迁移完成了，则替换旧桶数组，并设置下一次扩容阈值为新桶数组容量的 0.75 倍</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>finishing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    nextTable <span class="token operator">=</span> null<span class="token punctuation">;</span>
                    table <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>
                    sizeCtl <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">// 当前线程扩容完成，把扩容线程数-1</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">,</span> sc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                    <span class="token comment" spellcheck="true">// 扩容完成，条件成立，也就是此时是最后一个线程走到这里，和首次进行扩容的 sizeCtl 一样</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span>
                        <span class="token keyword">return</span><span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// 标记完成</span>
                    finishing <span class="token operator">=</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// i 重新赋值为 n，这样会再重新遍历一次桶数组，看看是不是都迁移完成了</span>
                    i <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// recheck before commit</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">// 如果桶中无数据，直接在旧桶的 i 位置放入 ForwardingNode 表示该桶已迁移完</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
                advance <span class="token operator">=</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 如果桶中第一个元素的 hash 值为 MOVED ，说明它是 ForwardingNode 节点，表示该桶已迁移完</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>
                advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// already processed</span>

                <span class="token comment" spellcheck="true">// 迁移 i 位置桶中的元素</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>

                <span class="token comment" spellcheck="true">// 锁定该桶，并迁移元素</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>

                    <span class="token comment" spellcheck="true">// 再次判断当前桶第一个元素是否有修改，也就是可能其它线程先一步迁移了元素</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> ln<span class="token punctuation">,</span> hn<span class="token punctuation">;</span>

                        <span class="token comment" spellcheck="true">// 桶中第一个元素 fh >= 0 说明桶是链表形式，这里与 HashMap 迁移算法基本一致，仅做了点优化</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token keyword">int</span> runBit <span class="token operator">=</span> fh <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>
                            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> lastRun <span class="token operator">=</span> f<span class="token punctuation">;</span>
                            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token keyword">int</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> runBit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                    runBit <span class="token operator">=</span> b<span class="token punctuation">;</span>
                                    lastRun <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>
                            <span class="token punctuation">}</span>

                            <span class="token comment" spellcheck="true">// 看看最后这几个元素归属于低位链表还是高位链表</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>runBit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                ln <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>
                                hn <span class="token operator">=</span> null<span class="token punctuation">;</span>
                            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                                hn <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>
                                ln <span class="token operator">=</span> null<span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>

                            <span class="token comment" spellcheck="true">// 遍历链表，把hash&amp;n为0的放在低位链表中，不为0的放在高位链表中</span>
                            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token keyword">int</span> ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
                                K pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
                                V pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                                    ln <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">else</span>
                                    hn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>

                            <span class="token comment" spellcheck="true">// 低位链表的位置不变 - CAS操作</span>
                            <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token comment" spellcheck="true">// 高位链表的位置是原位置加n - CAS操作</span>
                            <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>

                            <span class="token comment" spellcheck="true">// 使用 Unsafe 的 volatile 式标记该桶已迁移完成，即在该桶中放置 ForwardingNode 类型的元素以标记该桶迁移完成</span>
                            <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>

                            <span class="token comment" spellcheck="true">// advance为true，返回上面进行 --i 操作</span>
                            advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

                            <span class="token comment" spellcheck="true">// 如果桶中第一个元素是树节点，也是一样分化成两颗树，也是根据hash&amp;n为0放在低位树中，不为0放在高位树中， 基本同 HashMap</span>
                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> t <span class="token operator">=</span> <span class="token punctuation">(</span>TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">)</span> f<span class="token punctuation">;</span>
                            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> lo <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>
                            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> hi <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>
                            <span class="token keyword">int</span> lc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e <span class="token operator">=</span> t<span class="token punctuation">.</span>first<span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token keyword">int</span> h <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
                                TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span>
                                        <span class="token punctuation">(</span>h<span class="token punctuation">,</span> e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span>val<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> loTail<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
                                        lo <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                    <span class="token keyword">else</span>
                                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                    loTail <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                    <span class="token operator">++</span>lc<span class="token punctuation">;</span>
                                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> hiTail<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
                                        hi <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                    <span class="token keyword">else</span>
                                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                    hiTail <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                    <span class="token operator">++</span>hc<span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>
                            <span class="token punctuation">}</span>

                            <span class="token comment" spellcheck="true">// 如果分化的树中元素个数小于等于6，则退化成链表</span>
                            ln <span class="token operator">=</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span>
                                    <span class="token punctuation">(</span>hc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>
                            hn <span class="token operator">=</span> <span class="token punctuation">(</span>hc <span class="token operator">&lt;=</span> UNTREEIFY_THRESHOLD<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span>
                                    <span class="token punctuation">(</span>lc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>

                            <span class="token comment" spellcheck="true">// 低位树的位置不变 - CAS操作</span>
                            <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token comment" spellcheck="true">// 高位树的位置是原位置加n - CAS操作</span>
                            <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>

                            <span class="token comment" spellcheck="true">// 使用 Unsafe 的 volatile 式标记该桶已迁移，即在桶中放置 ForwardingNode 类型的元素，标记该桶迁移完成</span>
                            <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token comment" spellcheck="true">// advance为true，返回上面进行--i操作</span>
                            advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>

                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>上述方法实现了<strong>扩容和迁移元素</strong>的逻辑。下面我们先对关键步骤进行说明，然后再对并发处理进行分析。</p>
<ol>
<li>如果还没开始扩容，那么就先进行扩容，扩容后的数组大小是旧数组的 2 倍；</li>
<li>创建完新的数组后，就可以开始将旧数组中的元素迁移到新数组中了，迁移的方式是从后往前逐个桶迁移：<ul>
<li>为当前执行的线程分配迁移的桶，该线程会根据具体情况处理该桶；</li>
<li>判断是否已经迁移完毕，迁移完毕就用新数组替换旧数组，并根据新数组的容量以 0.75 计算扩容阈值并赋予 sizeCtl，扩容过程结束；</li>
<li>判断当前桶是否为空，为空就直接 CAS 填充 ForwardingNode 对象，表示该桶迁移完了；</li>
<li>判断当前桶是否为 ForwardingNode 对象（也就是元素的 hash 值为 MOVED） ，如果是则表示该桶已经迁移完了，跳过即可；</li>
<li>以上条件都不成立，那么就锁定该桶，然后将该桶元素迁移到新数组中，迁移方式基本同 HashMap 的迁移方式，主要区别是在迁移完成后，使用 ForwardingNode 对象打标记，表示该桶已经完成了迁移；</li>
</ul>
</li>
</ol>
<p>在扩容时，ConcurrentHashMap 支持<strong>并发扩容</strong>，在扩容过程中同时支持查找元素。<strong>这种无阻塞算法，将并发度大大的提高了</strong>。下面我们就对并发处理进行分析。</p>
<ol>
<li>临时的新数组 nextTable 使用 volatile 修饰，保证可见性；</li>
<li>使用 ForwardingNode 类型对象封装新数组，这个对象非常重要，<strong>不仅作为旧数组某个桶迁移完成的标记，还支持了扩容时的元素查找</strong>；</li>
<li>使用 CAS 为不同的线程分配待迁移的不同桶，实现并发扩容；</li>
<li>使用 <code>synchronized</code> 分段锁保证迁移桶元素时的安全；</li>
</ol>
<h3 id="helpTransfer-辅助数据迁移"><a href="#helpTransfer-辅助数据迁移" class="headerlink" title="helpTransfer() - 辅助数据迁移"></a>helpTransfer() - 辅助数据迁移</h3><p>假设在进行 put 或 remove 操作时正处于迁移的过程，映射到的桶已经被迁移了（Node.hash==MOVED)，此时该怎么办呢？<strong>ConcurrentHashMap 采用的是辅助扩容的方式，完成扩容后再执行对应的写操作</strong>。</p>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**
     * 
     * 辅助扩容（迁移元素）
     * 
     *  f 所在桶元素迁移完了才去协助迁移其它桶元素
     *
     * @param tab 旧数组
     * @param f   一般为 ForwardingNode 类型
     */</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">;</span>
        <span class="token keyword">int</span> sc<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 如果桶数组不为空 &amp;&amp; 当前桶第一个元素 f 是 ForwardingNode 类型 &amp;&amp; 封装的 nextTab（新数组） 不为空，说明当前桶已经迁移完毕了，才去帮忙迁移其它桶的元素。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">ForwardingNode</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span>nextTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ForwardingNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">)</span> f<span class="token punctuation">)</span><span class="token punctuation">.</span>nextTable<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token comment" spellcheck="true">// 获取扩容旧数组的标记位，类似 epoch 的概念</span>
            <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// sizeCtl &lt; 0 &amp;&amp; nextTable 不为空，说明集合正处于扩容过程</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> nextTable <span class="token operator">&amp;&amp;</span> table <span class="token operator">==</span> tab <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                <span class="token comment" spellcheck="true">// 协助迁移元素前，再次判断扩容是否结束，如果结束直接返回，无需协助迁移</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">>>></span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span> <span class="token operator">!=</span> rs <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span>
                        sc <span class="token operator">==</span> rs <span class="token operator">+</span> MAX_RESIZERS <span class="token operator">||</span> transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 扩容线程数加 1 ，标示多一个线程参与协助迁移</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 当前线程帮忙迁移元素</span>
                    <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token comment" spellcheck="true">// 帮忙迁移完元素后，返回新数组</span>
            <span class="token keyword">return</span> nextTab<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 非扩容过程，返回旧数组</span>
        <span class="token keyword">return</span> table<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>辅助扩容是为了支持并发扩容的，当检测到定位的桶是 <strong><code>MOVED</code></strong> 状态时，那么当前线程会先辅助一起完成扩容，然后再继续执行写操作，这个逻辑一般需要自旋支持，因此我们可以看到前面介绍的 put 方法有一个自旋逻辑，在后面要介绍的 remove 方法也是这么做的。下面我们对辅助扩容方法中关键点进行分析：</p>
<ol>
<li>判断是否在进行扩容的条件是 <strong>sizeCtl &lt; 0 &amp;&amp; nextTable != null</strong>，这两个条件缺一不可。<code>sizeCtl &lt; 0</code> 的情况有两种，一种是在初始化数组时，通过 CAS 设置为 -1 才能拿到初始化资格；另一种是在扩容的时候，通过 CAS 设置为一个负数，高16位和低16位分别表示扩容旧数组的 epoch，参与扩容的线程数，这个前文已经详细说明。<code>nextTable</code> 只有在扩容期间才不会为 null，扩容完成后会重置为 null；</li>
<li>在迁移元素前，需要再次判断扩容是否结束，结束的情况下旧直接返回即可；没有结束的话，就更新 <code>sizeCtl</code> 的值，也就是增加参与扩容线程数；</li>
<li>如果参与了协助扩容，就返回扩容完成后的新数组；如果没有参与扩容，那么还是返回旧数组；</li>
</ol>
<h3 id="remove-删除元素"><a href="#remove-删除元素" class="headerlink" title="remove() - 删除元素"></a>remove() - 删除元素</h3><p>删除元素和添加元素逻辑类似，都是先定位对应的桶，如果该桶被标记迁移了，那么就先辅助迁移元素，完成迁移后继续执行写操作；如果桶没有被标志迁移，那么就采用 <code>synchronized</code> 分段锁锁住整个桶，然后执行对应的写操作。</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> V <span class="token function">remove</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 调用替换节点方法</span>
        <span class="token keyword">return</span> <span class="token function">replaceNode</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

   <span class="token keyword">final</span> V <span class="token function">replaceNode</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Object cv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 计算 hash</span>
        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 自旋</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> f<span class="token punctuation">;</span>
            <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 如果数组为空，或目标 key 所在的桶不存在，跳出循环返回 null</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>
                    <span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 如果桶中第一个元素的 hash 值为 MOVED ，说明这个桶已经迁移完了，但是其它的桶不知道，因此当前线程协助迁移，协助扩容完成后再进行删除操作</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>
                tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 查找元素并执行删除</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                V oldVal <span class="token operator">=</span> null<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 标记是否处理过</span>
                <span class="token keyword">boolean</span> validated <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 加锁（锁对象使用桶的第一个元素，达到分段的效果）</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 再次验证当前桶的第一个元素是否被修改</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>

                        <span class="token comment" spellcheck="true">// 桶的第一个元素的 hash >= 0 表示是链表节点</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            validated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

                            <span class="token comment" spellcheck="true">// 遍历链表寻找目标节点</span>
                            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e <span class="token operator">=</span> f<span class="token punctuation">,</span> pred <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                K ek<span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                                        <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>
                                                <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                    <span class="token comment" spellcheck="true">// 找到目标节点</span>
                                    V ev <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>

                                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cv <span class="token operator">==</span> null <span class="token operator">||</span> cv <span class="token operator">==</span> ev <span class="token operator">||</span>
                                            <span class="token punctuation">(</span>ev <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> cv<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                        oldVal <span class="token operator">=</span> ev<span class="token punctuation">;</span>

                                        <span class="token comment" spellcheck="true">// 如果 value 不为空则替换旧值</span>
                                        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                                            e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                                        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                                            <span class="token comment" spellcheck="true">// 如果前置节点不为空，删除当前节点</span>
                                            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                                        <span class="token keyword">else</span>
                                            <span class="token comment" spellcheck="true">// 如果前置节点为空，说明是桶中第一个元素，删除即可</span>
                                            <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                    <span class="token punctuation">}</span>
                                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>
                                pred <span class="token operator">=</span> e<span class="token punctuation">;</span>


                                <span class="token comment" spellcheck="true">// 遍历到链表尾部还没找到元素，跳出循环</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
                                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>

                            <span class="token comment" spellcheck="true">// 桶的第一个元素类型为树，则遍历树找目标节点</span>
                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            validated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                            TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> t <span class="token operator">=</span> <span class="token punctuation">(</span>TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">)</span> f<span class="token punctuation">;</span>
                            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> r<span class="token punctuation">,</span> p<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> t<span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>
                                    <span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">findTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>

                                <span class="token comment" spellcheck="true">// 找到目标节点</span>
                                V pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>cv <span class="token operator">==</span> null <span class="token operator">||</span> cv <span class="token operator">==</span> pv <span class="token operator">||</span>
                                        <span class="token punctuation">(</span>pv <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> cv<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>pv<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                    oldVal <span class="token operator">=</span> pv<span class="token punctuation">;</span>
                                    <span class="token comment" spellcheck="true">// 如果value不为空则替换旧值</span>
                                    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                                        p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                                        <span class="token comment" spellcheck="true">// 如果 value 为空，从树中删除</span>
                                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>

                                        <span class="token comment" spellcheck="true">// 判断是否退化成链表</span>
                                        <span class="token comment" spellcheck="true">//  t.removeTreeNode(p)这个方法返回true表示删除节点后树的元素个数较少，此时退化成链表</span>
                                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">// 如果处理过，就不需要循环了，可以退出了</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>validated<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 如果找到了元素，返回其旧值</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment" spellcheck="true">// 如果要替换的值为空，元素个数减 1，不考虑调整数组大小</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span>
                            <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token operator">-</span>1L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 没找到元素返回空</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>删除方法和新增方法类似，就不再说明。需要注意的一点是，如果定位到的桶是以红黑树存储的，那么删除元素后需要判断是否要退化为链表。</p>
<h3 id="get-获取元素"><a href="#get-获取元素" class="headerlink" title="get() - 获取元素"></a>get() - 获取元素</h3><p>一般来说，对于 get 操作是没有线程安全问题的，只有可见性的问题，只需要确保获取的元素是线程间可见的即可，针对这个问题 ConcurrentHashMap 使用 <code>volatile</code> 关键字修饰节点的值 val 和后继指针来保证可见性。</p>
<p>除了可见性问题，ConcurrentHashMap 还需要解决一个问题，这个问题是由其支持<strong>并发扩容</strong>带来的。也就是说，<strong>在扩容期间访问元素的时候，集合中的元素可能分布在新旧两个数组中</strong>，针对这种情况的访问策略是，先访问旧数组，如果旧数组相应位置的桶已经被标记迁移完成了，那么就需要继续访问新数组以查询目标元素，否则只需访问旧数组即可（注意，即使定位到的旧数组桶处于迁移过程也没关系，在完成迁移之前该桶中的元素之间的关联是不变的）。而这个策略实现的核心是 <strong><code>ForwardingNode</code></strong> 类型对象，它作为旧数组某个桶迁移完成的标记的同时，内部封装了新数组，并且重写了查找元素的方法，而这个重写的查找方法就是从新数组中查找元素的。</p>
<p>下面我们对源码进行分析，看看 ConcurrentHashMap 具体是如何实现的。</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e<span class="token punctuation">,</span> p<span class="token punctuation">;</span>
        <span class="token keyword">int</span> n<span class="token punctuation">,</span> eh<span class="token punctuation">;</span>
        K ek<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 计算 hash</span>
        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 如果元素所在的桶存在且里面有元素</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
                 <span class="token comment" spellcheck="true">// 使用 Unsafe 的 volatile 式获取节点，保证最新值</span>
                <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token comment" spellcheck="true">// 如果第一个元素就是要找的元素，直接返回</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// hash &lt; 0 说明第一个元素是树类型，或者数组处于扩容过程（元素类型是 ForwardingNode）</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token comment" spellcheck="true">// 使用find寻找元素，find的寻找方式依据Node的不同子类有不同的实现方式：</span>
                <span class="token comment" spellcheck="true">// 处于扩容过程：java.util.concurrent.ConcurrentHashMap.ForwardingNode.find</span>
                <span class="token comment" spellcheck="true">// 非扩容过程，也就是树类型：java.util.concurrent.ConcurrentHashMap.TreeNode.find</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">?</span> p<span class="token punctuation">.</span>val <span class="token operator">:</span> null<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 执行到这里，说明元素所在的桶中是链表，遍历链表即可</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 没有找到</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<ol>
<li>在访问元素时会计算 key 的 hash 值;</li>
<li>如果定位到的桶元素就是要查找的元素，那么直接返回对应的 value；</li>
<li>如果定位到的桶元素不是要查找的元素，那么就需要做出判断，这个判断非常重要，对应三种情况：<ul>
<li>如果桶元素的 <code>hash &lt; 0 &amp;&amp; hash == -1</code>，那么说明桶元素的类型是 <strong>ForwardingNode</strong>，此时集合处于扩容过程，查找元素调用 ForwardingNode 实现的查找方法；</li>
<li>如果桶元素的 <code>hash &lt; 0 &amp;&amp; hash == -2</code>，那么说明桶元素的类型是 <strong>TreeNode</strong>，是一颗红黑树，查找元素调用 TreeNode 实现的查找方法；</li>
<li>不是前面两种情况，那么桶中就是链表，遍历链表查找即可；</li>
</ul>
</li>
<li>没有定位到对应的桶，直接返回 null；</li>
</ol>
<p>关于链表和红黑树查找没有可说的，下面我们对处于扩容状态的查找进行分析。</p>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**
     * 扩容期间作为桶迁移完成的标志元素
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ForwardingNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">/**
         * 扩容期间的新数组。保存新Node数组的引用是为了支持在迁移的过程不阻塞地查找值。
         */</span>
        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTable<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/**
         * 构造方法
         *
         * @param tab 新数组
         */</span>
        <span class="token function">ForwardingNode</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// hash 固定为 MOVED </span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>MOVED<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>nextTable <span class="token operator">=</span> tab<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">/**
         * 扩容期间查找元素，那么从扩容期间的新数组查找
         *    
         * @param h
         * @param k
         * @return
         */</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> Object k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// loop to avoid arbitrarily deep recursion on forwarding nodes</span>
            outer<span class="token operator">:</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> nextTable<span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e<span class="token punctuation">;</span>
                <span class="token keyword">int</span> n<span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 新的数组为空，或者对应的桶为空，直接返回</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> null <span class="token operator">||</span> tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>
                        <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
                    <span class="token keyword">return</span> null<span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 定位桶查找目标元素</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">int</span> eh<span class="token punctuation">;</span>
                    K ek<span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// 判断是否是要查找的元素</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span>
                            <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> k <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> k<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> e<span class="token punctuation">;</span>

                    <span class="token comment" spellcheck="true">// 非链表的情况</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment" spellcheck="true">// 如果元素是 ForwardingNode ，说明该桶的元素已经迁移到新的数组中，那么需要从新的数组中查找</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">ForwardingNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            tab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ForwardingNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">)</span> e<span class="token punctuation">)</span><span class="token punctuation">.</span>nextTable<span class="token punctuation">;</span>
                            <span class="token keyword">continue</span> outer<span class="token punctuation">;</span>

                            <span class="token comment" spellcheck="true">// 如果 e 元素对应的桶还没有迁移，则根据红黑树查找</span>
                        <span class="token punctuation">}</span> <span class="token keyword">else</span>
                            <span class="token keyword">return</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>

                    <span class="token comment" spellcheck="true">// 遍历链表</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
                        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>至此，**<code>ForwardingNode</code>** 这个特殊节点的作用已经介绍完毕了，下面再进行总结：</p>
<ul>
<li>标识旧数组某个桶迁移完成，以支持并发扩容；</li>
<li>封装新数组，以支持在迁移的过程中非阻塞查找值；</li>
</ul>
<h4 id="浅谈Redis-rehash"><a href="#浅谈Redis-rehash" class="headerlink" title="浅谈Redis rehash"></a>浅谈Redis rehash</h4><p>如果了解 Redis 的扩容机制的话，你会发现两者有异曲同工之处。</p>
<ul>
<li><strong>扩容操作：</strong>Redis 实现的是渐进式 rehash，主线程以一定的步长迁移桶元素；ConcurrentHashMap 实现的是辅助扩容，多个线程可以并发迁移桶元素；</li>
<li><strong>扩容期间查找元素：</strong>Redis 在扩容的时候使用到了两个哈希表，会先从 0 号哈希表查找，没有再从 1 号哈希表查找；ConcurrentHashMap 在扩容过程也同时使用了两个桶数组，查找的时候也会先到旧数组中定位桶元素，如果桶元素是迁移标识元素 ForwardingNode，那么会再从新数组中查找；</li>
</ul>
<h2 id="JDK1-7-与-JDK1-8的区别"><a href="#JDK1-7-与-JDK1-8的区别" class="headerlink" title="JDK1.7 与 JDK1.8的区别"></a>JDK1.7 与 JDK1.8的区别</h2><p>JDK 1.7 的核心实现也采用了分段锁的技术，每个段 Segment 中对应一个小 HashMap，Segment 通过继承 ReentrantLock 来保证其内部的 HashMap 安全。</p>
<p>JDK 1.8 废弃了 Segment 分段锁的实现，采用<strong>多种 CAS + Node 级别的 synchronized 锁</strong>来保证并发安全，整体减小了锁竞争，减小程序同步的部分。</p>
<p>​                        </p>
<h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h2><p>这里我们讨论的一致性问题是针对 put 和 get 方法来说的。</p>
<p>JDK 1.7 的实现中 ConcurrentHashMap 表现为弱一致性，因为写操作只是简单赋值操作，读操作也是简单读操作。具体实现如下：</p>
<p><strong>写操作：</strong></p>
<pre class=" language-java"><code class="language-java">V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>读操作：</strong></p>
<pre class=" language-java"><code class="language-java">V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// read-volatile</span>
        HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> <span class="token function">getFirst</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                V v <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                    <span class="token keyword">return</span> v<span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token function">readValueUnderLock</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// recheck</span>
            <span class="token punctuation">}</span>
            e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在进行写操作时，先加锁，然后直接给数组中的桶赋值，此时虽然数组 tab 使用 vlolatile 修饰保证可见性，但是不保证元素的可见性，因此无法保证能及时读取到写入的元素。由此可以看出，在 JDK 1.8 之前的读写操作是弱一致性的。</p>
<p>要保证读写强一致性，一般可以加锁，或者使用 volatile 修饰变量。如果采用加锁的方式，会导致 ConcurrentHashMap 的性能问题，这也违背了设计的初衷，因此可以考虑使用 volatile 来保证可见性。但是我们需要知道的是，volatile 可以修饰变量却不能修饰数组中的元素，也就是修饰数组只能保证数组的地址可见性。</p>
<p>JDK 1.8 正是从上述点进行突破，使用了 Unsafe 类来实现数组元素的可见性。</p>
<p><strong>写操作：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 使用 Unsafe 类 volatile 式的操作查看值</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果数组该位置没有节点，则使用一次 CAS 操作将这个新值放入其中即可。  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span>
                     <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">boolean</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span>
                                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> c<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> U<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i <span class="token operator">&lt;&lt;</span> ASHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> ABASE<span class="token punctuation">,</span> c<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>读操作：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token comment" spellcheck="true">// 如果元素所在的桶存在且里面有元素 </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
      <span class="token comment" spellcheck="true">// 使用 Unsafe 的 volatile 式获取节点，保证最新值</span>
      <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">tabAt</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>U<span class="token punctuation">.</span><span class="token function">getObjectVolatile</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i <span class="token operator">&lt;&lt;</span> ASHIFT<span class="token punctuation">)</span> <span class="token operator">+</span> ABASE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>写操作使用 CAS 更新内存中数组中的元素；</li>
<li>读操作使用 Unsafe 的 volatile 式获取内存中数组中的元素；</li>
</ul>
<p>由于读写都是直接对内存操作，所以通过上述方式可以保证 put 和 get 的强一致性。ConcurrentHashMap 是通过 <code>compareAndSwapObject</code> 来取代对数组元素直接赋值的操作，通过 <code>getObjectVolatile</code> 来弥补无法对数组元素进行 volatile 读的缺陷。</p>
<p>需要注意，JDK 1.8 下的 ConcurrentHashMap 并非所有操作都是强一致性的，其中计算集合元素个数的 size() 方法就是弱一致性的，具体原因通过前面的源码就能看出来。</p>
<h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><p>ConcurrentHashMap 运用各类 CAS 操作保证并发安全，并在关键逻辑位置使用 <code>synchronized</code> 分段锁以小范围进行锁定保证安全。</p>
<p>在扩容时，ConcurrentHashMap 支持多线程并发扩容，在扩容过程的同时支持 get 获取元素，这种无阻塞算法，大大提高了并发度。其中，整个扩容过程都是通过 CAS 控制 <strong>sizeCtl</strong> 这个属性来进行的，某个桶完成迁移会使用 ForwardingNode 节点填充以标识该桶迁移完毕。整个迁移过程类似 Redis 中的 rehash 过程。</p>
<p>ConcurrentHashMap 元素个数的存储采用的是<strong>分段存储</strong>思想，类似 LongAdder 的实现，提高并发度。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>ConcurrentHashMap 设计非常精妙，读完源码后收获很大，很多设计让人眼前一亮，也开阔了技术视野。</p>
<ul>
<li>自旋 + CAS，采用乐观锁的思想，避免线程阻塞，减少线程上下文切换的时间；</li>
<li>分段锁的思想，使用 <code>synchronized</code> 锁住单个桶对象以减小锁范围；</li>
<li>分段存储集合元素个数，减小并发更新一个字段的竞争；</li>
<li>支持并发扩容，尽可能无阻塞实现读写；</li>
</ul>
<p><strong>参考：</strong></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/1yWSfdz0j-PprGkDgOomhQ">漫画：什么是ConcurrentHashMap</a></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Huowy</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://carefulhuo.github.io/posts/1ea4c5c4.html">https://carefulhuo.github.io/posts/1ea4c5c4.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Huowy</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Map/">
                                    <span class="chip bg-color">Map</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="../medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="../medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    
        <style>
    .mvaline-card {
        margin: 1.5rem auto;
    }

    .mvaline-card .card-content {
        padding: 20px 20px 5px 20px;
    }

</style>

<div class="card mvaline-card" data-aos="fade-up">
    <div class="comment_headling"
        style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 25px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div class="card-content" style="display: grid">
        <div id="tcomment">
    </div>
    </div>
</div>


<script src="https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js "></script>

<script>
    twikoo.init({
        envId: 'https://twikoo-jet-pi.vercel.app', // 腾讯云环境填 envId；Vercel 环境填地址（https://xxx.vercel.app）
        el: '#tcomment', // 容器元素
        // region: 'ap-guangzhou', // 环境地域，默认为 ap-shanghai，腾讯云环境填 ap-shanghai 或 ap-guangzhou；Vercel 环境不填
        // path: location.pathname, // 用于区分不同文章的自定义 js 路径，如果您的文章路径不是 location.pathname，需传此参数
        lang: 'zh-CN', // 用于手动设定评论区语言，支持的语言列表 https://github.com/imaegoo/twikoo/blob/main/src/js/utils/i18n/index.js
    })
</script>
    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/e1fb5f02.html">
                    <div class="card-image">
                        
                        
                        <img src="../medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/medias/featureimages/19.jpg" class="responsive-img" alt="小情话第六百三十则">
                        
                        <span class="card-title">小情话第六百三十则</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            这个文章-博主不想让其他人看见哟~
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-06-01
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/" class="post-category">
                                    程序员的浪漫
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Little-Love/">
                        <span class="chip bg-color">Little Love</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/5813eb3b.html">
                    <div class="card-image">
                        
                        
                        <img src="../medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/medias/featureimages/1.jpg" class="responsive-img" alt="小情话第六百二十九则">
                        
                        <span class="card-title">小情话第六百二十九则</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            这个文章-博主不想让其他人看见哟~
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-05-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/" class="post-category">
                                    程序员的浪漫
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Little-Love/">
                        <span class="chip bg-color">Little Love</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2020-2022</span>
            
            <span id="year">2020</span>
            <a href="/about" target="_blank">Huowy</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">47.3k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "7";
                    var startDate = "5";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/CarefulHuo" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:hnzmdhwy@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1591733908" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1591733908" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>

    <script src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?803f264466e6b14667e7240f809335f7";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    
<!-- umami Analytics -->
<script>var _speedMark = new Date()</script>
<script async defer data-website-id="78e1f995-dc79-4dd1-8b4d-08e812a2bd26" src="https://umami-azure-iota.vercel.app/umami.js"></script>


    <!-- Baidu Push -->

    
    
    <script src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/others/clickchinese.js" type="text/javascript" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    

    
    <script src="https://cdn.jsdelivr.net/gh/CarefulHuo/carefulhuo.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 5,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>

</html>