[{"title":"Java8中新的日期和时间","date":"2020-10-26T02:04:59.000Z","path":"posts/dbba2e41/","text":"一.为什么我们需要新的Date和Time类！ Java8之前所有的日期类都是可变的，这就导致了线程不安全问题； java的日期和时间类的定义不一致，在java.util和java.sql中都包含日期类； java.util.Date同时包含日期和时间，但是java.sql中只包含日期，将其纳入java.sql中的是不合适的，而且更糟糕的是:这两个类中的日期类的名字都是一样的； 对于时间、时间戳、格式化及解析，没有一些明确定义的类，而且对于格式化和解析的需求，Java中有java.text.DateFormat抽象类，但是通常我们用的是SimpleDateFormate类进行格式化和解析 日期类不支持国际化，没有时区支持，即使Java引入了-java.util.Calendar和java.util.TimeZone类，但是问题依然存在。 二.新的日期和时间API的设计原则是 Java8中新的日期和时间是基于JSR-310实现的,参考了绝大多数的joda-timeApi。 不变性：新的日期/时间API中，所有的类都是不可变的，实现了线程安全； 关注点分离：新的API中将人可读的日期时间和机器时间(unix timestamp)明确分离，它为日期(Date)、时间(Time)、日期时间(DateTime)、时间戳(unix timestamp)以及时区定义了不同的类； 清晰明了：新的API中，方法都被明确定义用以完成相同的行为，例如，想要拿到当前实例，可以用new()方法，在所有的类方法中都实现了formate()和parse()方法，不再是之前用单独一个类去解决，而且新的API中所有的类都使用了工厂模式和策略模式； 实用性：所有新的日期和时间API类都实现了一系列方法用以完成通用的需求，例如：加、减、格式化、解析、从日期或时间中提取单独部分等等； 可扩展性：新的日期/时间API是基于国际标准ISO 8601,其实我们也是可以将其用于非IOS的日历上 三.Java8中的日期和时间API包含以下包 java.time包：这是新的Java日期/时间API的基础包，所有的主要基础类都是该包的一部分，例如：LocalDate、LocalTime、LocalDateTime、Instant、Period、Duration等类。这些类都是线程安全的 java.time.chrono包：这个包为非ISO的日历标准定义了一些泛化的API，我们可以拓展AbstractChronology来创建自己的日历标准 java.time.formate包：这个包包含能够格式化和解析日期时间对象的类，在绝大数情况下，我们不应该直接使用它，因为java.time包中相应的类已经提供了格式化和解析的方法 java.time.temporal包：这个包包含一些时态对象，可以用其找出关于某个日期/时间对象的某个特定日期或时间，比如说找到某个月的第一天或最后一天，可以根据withXXX的格式进行区分 java.time.zone包：这个包支持不同的时区以及相关规则的类 Java8中引入的关于日期和时间的新类：Period和Duration类，两个类表示两个日期和时间之间的差，Period基于日期，Duration类基于时间 四.Period类 概述：该类表示一段时间的年、月、日 使用该类中between()方法获取两个日期之间的差作为Period对像返回；1234567// 代码示例 LocalDate startTime = LocalDate.of(2020,10,01); LocalDate endTime = LocalDate.of(2021,11,20); Period timeSub = Period.between(startTime,endTime); System.out.println(\"year:\"+timeSub.getYears()); System.out.println(\"month:\"+timeSub.getMonths()); System.out.println(\"day:\"+timeSub.getDays()); 使用该类中的isNegative()方法判断起止日期的大小(false为endTime大于startTime，否则相反)原理是根据该该方法(不需要参数)会校验Period对象中的天、月、年是否为负，为负则返回true，为正则返回false12345// 代码示例 LocalDate startTime = LocalDate.of(2020,10,01); LocalDate endTime = LocalDate.of(2021,11,20); Period timeSub = Period.between(startTime,endTime); System.out.println(timeSub.isNegative()); 使用该类的plusXXX()方法、minusXXX()方法可以进行日期的增加和减少1234567891011// 代码示例 Period periodTime = Period.of(2020,10,26); //年 String plusYears = periodTime.plusYears(1).toString(); String minusYears = periodTime.minusYears(1).toString(); //月 String plusMonths = periodTime.plusMonths(1).toString(); String minusMonths = periodTime.minusMonths(1).toString(); //日 String plusDays = periodTime.plusDays(1).toString(); String minusDays = periodTime.minusDays(1).toString(); 五.Duration类 概述：表示秒或纳秒的时间间隔，适合处理较短的时间，且需要更高的精确性 使用该类中between()方法比较两个瞬间的差值123456// 代码示例 Instant start = Instant.parse(\"2020-10-12T10:12:12.00Z\"); Instant end = Instant.now(); System.out.println(end.toString()); Duration duration = Duration.between(start,end); System.out.println(duration.isNegative()); 使用该类中的isNegative()方法判断起止时间的大小(false为endTime大于startTime，否则相反)原理是根据该该方法(不需要参数)会校验Duration对象中的天、月、年是否为负，为负则返回true，为正则返回false12345// 代码示例(使用LocalTime也可以获取Duration对象) LocalTime startTime = LocalTime.of(1,10,30,234); LocalTime endTime = LocalTime.of(1,20,30,234); Duration duration = Duration.between(startTime,endTime); System.out.println(duration.isNegative()); 使用该类的plusXXX()方法、minusXXX()方法可以进行日期的增加和减少123456789101112131415// 代码示例(使用该类中的ofDays方法也可以获取Duration对象) Duration durationDays = Duration.ofDays(1); String addDays = durationDays.plusDays(1).toString(); System.out.println(durationDays.getSeconds()); Duration durationHours = Duration.ofHours(3); String minusHours = durationHours.minusHours(1).toString(); System.out.println(durationHours.getSeconds()); Duration durationMinutes = Duration.ofMinutes(1); System.out.println(durationMinutes.getSeconds()); Duration durationMillis = Duration.ofMillis(1); System.out.println(durationMillis.getSeconds()); System.out.println(durationMillis.getNano()); 六.Instant类 概述：表示某个时间，不带时区的即时时间点，精确到纳秒 内部由两个Long字段组成，第一部分保存自标准Java时代到现在的秒数，第二部分保存的是纳秒数(不会超过999,999,999)。注意：通过这种方式获取的时间戳与北京时间相差8个时区，需要修正为北京时间，通过查看源代码发现Instant.now()使用等是UTC时间Clock.systemUTC().instant()。LocalDate、LocalDateTime 的now()方法使用的是系统默认时区 不存在Instant.now()的时间问题。 Instant相当于Date,以下是相互转换12345678910111213141516// 代码示例 //类方法java.time.Instant Instant instant = Instant.now(); System.out.println(instant); Instant beijingTime = Instant.now().plus(8, ChronoUnit.HOURS); System.out.println(beijingTime); //类方法java.util.Date Date date = new Date(); System.out.println(date); date = Date.from(instant); System.out.println(date); instant = date.toInstant(); System.out.println(instant); Instant类中通过固定时间转换为Instant对象的方法12345678910111213//根据Date转换为instant(java.util.Instant中方法)Date date = new Date();Instant instant = Instant.ofEpochMilli(date.getTime());System.out.println(instant);//根据毫秒转换为instant(java.util.Instant中方法)instant = Instant.ofEpochMilli(1000 * 60 * 60 * 24);System.out.println(instant);//根据秒转换为instant(java.util.Instant中方法)instant = Instant.ofEpochSecond(60 * 60 * 24 * 5);System.out.println(instant);//根据秒和纳秒转换为instant(java.util.Instant中方法)，这样得到的instant会包含纳秒的数据 1000000000纳秒（9位）=1秒instant = Instant.ofEpochSecond(60 * 60 * 24,1000000000*60);System.out.println(instant); Instant类中的parse方法1234// 代码示例 //该方法的入参仅支持UTC格式的字符串，而且date结果的字符串会报出DateTimeParseException异常 Instant instant = Instant.parse(\"2020-10-26T12:10:00Z\"); System.out.println(instant); Instant类中的加减日期方法(加)plus()和(减)minus()方法123456789101112131415161718192021// 代码示例 //ChronoUnit位于java.time.temporal,Periodjava位于Java.time //plus()方法会产生一个新的instant对象 //plus()方法给当前日期增加五天 Instant instant = Instant.now(); Instant instantAddDayOne = instant.plus(5, ChronoUnit.DAYS); Instant instantAddDayTwo = instant.plus(Period.ofDays(5)); Instant instantAddDayTwo1 = instant.plus(Duration.ofDays(5)); System.out.println(instantAddDayOne.toString()); System.out.println(instantAddDayTwo.toString()); System.out.println(instantAddDayTwo1.toString()); System.out.println(instant == instantAddDayOne); //minus()方法会产生一个新的instant对象 //minus()方法给当前日期减少五天 Instant instantSubDay = instant.minus(5, ChronoUnit.DAYS); Instant instantSubDayTwo = instant.minus(Period.ofDays(5)); Instant instantSubDayTwo1 = instant.minus(Duration.ofDays(5)); System.out.println(instantSubDay); System.out.println(instantSubDayTwo); System.out.println(instantSubDayTwo1); System.out.println(instant == instantSubDayTwo); Instant类中比较两个日期的大小12345678910111213141516// 代码示例 Instant instantNow = Instant.now(); Instant instantAddDay = instantNow.plus(Duration.ofDays(5)); //isAfter()方法判断instantAddDay是否在instantNow之后 boolean flgAfter = instantAddDay.isAfter(instantNow); System.out.println(flgAfter); //isBefore()方法判断instantAddDay是否在instantNow之前 boolean flgBefore = instantAddDay.isBefore(instantNow); System.out.println(flgBefore); //compareTo()方法比较，前者时间纳秒值大于后者返回1，小于返回-1，等于返回0 int result1 = instantAddDay.compareTo(instantNow); System.out.println(result1); int result2 = instantNow.compareTo(instantAddDay); System.out.println(result2); int result3 = instantNow.compareTo(instantNow); System.out.println(result3); Instant类计算两个日期的差值12345678910// 代码示例 Instant instantNow = Instant.now(); Instant instantAddDay = instantNow.plus(Duration.ofDays(5)); //between()方法后者比前者大，返回正数，比前者小返回负数，相等返回0(ChronoUnit.DAYS位于java.time.temporal) long result1 = ChronoUnit.DAYS.between(instantNow, instantAddDay); System.out.println(result1); long result2 = ChronoUnit.DAYS.between(instantAddDay, instantNow); System.out.println(result2); long result3 = ChronoUnit.DAYS.between(instantNow, instantNow); System.out.println(result3); 七.LocalDateTime类 概述：表示不带时区的日期及时间，替换之前的Calendar 注意:看上去，LocalDateTime和Instant很象，但记得的是“Instant中是不带时区的即时时间点。可能有人说，即时的时间点 不就是日期＋时间么？看上去是这样的，但还是有所区别，比如LocalDateTime对于用户来说，可能就只是一个简单的日期和时间的概念，考虑如下的 例子：两个人都在2013年7月2日11点出生，第一个人是在英国出生，而第二个是在加尼福利亚，如果我们问他们是在什么时候出生的话，则他们看上去都是 在同样的时间出生（就是LocalDateTime所表达的），但如果我们根据时间线（如格林威治时间线）去仔细考察，则会发现在出生的人会比在英国出生的人稍微晚几个小时（这就是Instant所表达的概念，并且要将其转换为UTC格式的时间）。 LocalDateTime获取当前时间(系统自带默认时间)123// 代码示例 LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(localDateTime); LoclaDateTime类中时间加减计算(加)plusXXX()和(减)minusXXX()方法12345678// 代码示例 // plus()和minus()方法与Instant类中相同 LocalDateTime localDateTime1 = localDateTime.plusHours(5); System.out.println(localDateTime1); System.out.println(localDateTime1 == localDateTime); LocalDateTime localDateTime2 = localDateTime.minusHours(5); System.out.println(localDateTime2); System.out.println(localDateTime2 == localDateTime); LocalDateTime显示年月日，不显示时间;显示时间，不显示年月12345678// 代码示例 LocalDateTime localDateTime = LocalDateTime.now(); //显示年月日，且增加两个月 LocalDate localDate = localDateTime.toLocalDate().plusMonths(2); System.out.println(localDate); //显示时分秒毫秒，且减少两个小时 LocalTime localTime = localDateTime.toLocalTime().minusHours(2); System.out.println(localTime); LocalDateTime类中格式化日期的两种方式12345678// 代码示例 //通过Instant类获取当前系统时间，ZoneId.systemDefault设置为系统默认时区 //ZoneId位于java.time LocalDateTime localDateTime1 = LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault()); System.out.println(localDateTime1); //通过DateTimeFormatter类中的ofPattern方法获取自定义格式的系统时间，位于java.time.format String localDateTimeStr = localDateTime1.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")); System.out.println(localDateTimeStr); 文章借鉴处 https://blog.csdn.net/fragrant_no1/article/details/83988042 https://blog.csdn.net/neweastsun/article/details/88770592 https://blog.csdn.net/liubenlong007/article/details/62039628","content":"<h4>一.为什么我们需要新的Date和Time类！</h4>\n\n<a id=\"more\"></a>\n<ul>\n<li>Java8之前所有的日期类都是可变的，这就导致了线程不安全问题；</li>\n<li>java的日期和时间类的定义不一致，在java.util和java.sql中都包含日期类；</li>\n<li>java.util.Date同时包含日期和时间，但是java.sql中只包含日期，将其纳入java.sql中的是不合适的，而且更糟糕的是:这两个类中的日期类的名字都是一样的；</li>\n<li>对于时间、时间戳、格式化及解析，没有一些明确定义的类，而且对于格式化和解析的需求，Java中有java.text.DateFormat抽象类，但是通常我们用的是SimpleDateFormate类进行格式化和解析</li>\n<li>日期类不支持国际化，没有时区支持，即使Java引入了-java.util.Calendar和java.util.TimeZone类，但是问题依然存在。<!-- more -->\n\n</li>\n</ul>\n<h4>二.新的日期和时间API的设计原则是</h4>\n\n<p>Java8中新的日期和时间是基于JSR-310实现的,参考了绝大多数的<a href=\"https://www.joda.org/joda-time/\" target=\"_blank\" rel=\"noopener\">joda-time</a>Api。</p>\n<ul>\n<li>不变性：新的日期/时间API中，所有的类都是不可变的，实现了线程安全；</li>\n<li>关注点分离：新的API中将人可读的日期时间和机器时间(unix timestamp)明确分离，它为日期(Date)、时间(Time)、日期时间(DateTime)、时间戳(unix timestamp)以及时区定义了不同的类；</li>\n<li>清晰明了：新的API中，方法都被<strong>明确定义</strong>用以完成<strong>相同的行为</strong>，例如，想要拿到当前实例，可以用new()方法，在所有的类方法中都实现了formate()和parse()方法，不再是之前用单独一个类去解决，而且新的API中所有的类都使用了工厂模式和策略模式；</li>\n<li>实用性：所有新的日期和时间API类都实现了一系列方法用以完成通用的需求，例如：加、减、格式化、解析、从日期或时间中提取单独部分等等；</li>\n<li>可扩展性：新的日期/时间API是基于<a href=\"https://baike.baidu.com/item/ISO%208601\" target=\"_blank\" rel=\"noopener\">国际标准ISO 8601</a>,其实我们也是可以将其用于非IOS的日历上</li>\n</ul>\n<h4>三.Java8中的日期和时间API包含以下包</h4>\n\n<ul>\n<li>java.time包：这是新的Java日期/时间API的基础包，所有的主要基础类都是该包的一部分，例如：LocalDate、LocalTime、LocalDateTime、Instant、Period、Duration等类。这些类都是线程安全的</li>\n<li>java.time.chrono包：这个包为非ISO的日历标准定义了一些泛化的API，我们可以拓展AbstractChronology来创建自己的日历标准</li>\n<li>java.time.formate包：这个包包含能够格式化和解析日期时间对象的类，<strong>在绝大数情况下，我们不应该直接使用它</strong>，因为java.time包中相应的类已经提供了格式化和解析的方法</li>\n<li>java.time.temporal包：这个包包含一些时态对象，可以用其找出关于某个日期/时间对象的某个特定日期或时间，比如说找到某个月的第一天或最后一天，可以根据withXXX的格式进行区分</li>\n<li>java.time.zone包：这个包支持不同的时区以及相关规则的类</li>\n</ul>\n<hr>\n<p>Java8中引入的关于日期和时间的新类：Period和Duration类，两个类表示两个日期和时间之间的差，Period基于日期，Duration类基于时间</p>\n<h4>四.Period类</h4>\n概述：该类表示一段时间的年、月、日\n\n<ol>\n<li>使用该类中between()方法获取两个日期之间的差作为Period对像返回；<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例</span></span><br><span class=\"line\">        LocalDate startTime = LocalDate.of(<span class=\"number\">2020</span>,<span class=\"number\">10</span>,<span class=\"number\">01</span>);</span><br><span class=\"line\">        LocalDate endTime = LocalDate.of(<span class=\"number\">2021</span>,<span class=\"number\">11</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">        Period timeSub = Period.between(startTime,endTime);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"year:\"</span>+timeSub.getYears());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"month:\"</span>+timeSub.getMonths());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"day:\"</span>+timeSub.getDays());</span><br></pre></td></tr></table></figure></li>\n<li>使用该类中的isNegative()方法判断起止日期的大小<br>(false为endTime大于startTime，否则相反)原理是根据该该方法(不需要参数)会校验Period对象中的天、月、年是否为负，为负则返回true，为正则返回false<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例</span></span><br><span class=\"line\">        LocalDate startTime = LocalDate.of(<span class=\"number\">2020</span>,<span class=\"number\">10</span>,<span class=\"number\">01</span>);</span><br><span class=\"line\">        LocalDate endTime = LocalDate.of(<span class=\"number\">2021</span>,<span class=\"number\">11</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">        Period timeSub = Period.between(startTime,endTime);</span><br><span class=\"line\">        System.out.println(timeSub.isNegative());</span><br></pre></td></tr></table></figure></li>\n<li>使用该类的plusXXX()方法、minusXXX()方法可以进行日期的增加和减少<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例</span></span><br><span class=\"line\">        Period periodTime = Period.of(<span class=\"number\">2020</span>,<span class=\"number\">10</span>,<span class=\"number\">26</span>);</span><br><span class=\"line\">        <span class=\"comment\">//年</span></span><br><span class=\"line\">        String plusYears = periodTime.plusYears(<span class=\"number\">1</span>).toString();</span><br><span class=\"line\">        String minusYears = periodTime.minusYears(<span class=\"number\">1</span>).toString();</span><br><span class=\"line\">        <span class=\"comment\">//月</span></span><br><span class=\"line\">        String plusMonths = periodTime.plusMonths(<span class=\"number\">1</span>).toString();</span><br><span class=\"line\">        String minusMonths = periodTime.minusMonths(<span class=\"number\">1</span>).toString();</span><br><span class=\"line\">        <span class=\"comment\">//日</span></span><br><span class=\"line\">        String plusDays = periodTime.plusDays(<span class=\"number\">1</span>).toString();</span><br><span class=\"line\">        String minusDays = periodTime.minusDays(<span class=\"number\">1</span>).toString();</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<hr>\n<h4>五.Duration类</h4>\n概述：表示秒或纳秒的时间间隔，适合处理较短的时间，且需要更高的精确性\n\n<ol>\n<li>使用该类中between()方法比较两个瞬间的差值<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例</span></span><br><span class=\"line\">        Instant start = Instant.parse(<span class=\"string\">\"2020-10-12T10:12:12.00Z\"</span>);</span><br><span class=\"line\">        Instant end = Instant.now();</span><br><span class=\"line\">        System.out.println(end.toString());</span><br><span class=\"line\">        Duration duration = Duration.between(start,end);</span><br><span class=\"line\">        System.out.println(duration.isNegative());</span><br></pre></td></tr></table></figure></li>\n<li>使用该类中的isNegative()方法判断起止时间的大小<br>(false为endTime大于startTime，否则相反)原理是根据该该方法(不需要参数)会校验Duration对象中的天、月、年是否为负，为负则返回true，为正则返回false<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例(使用LocalTime也可以获取Duration对象)</span></span><br><span class=\"line\">        LocalTime startTime = LocalTime.of(<span class=\"number\">1</span>,<span class=\"number\">10</span>,<span class=\"number\">30</span>,<span class=\"number\">234</span>);</span><br><span class=\"line\">        LocalTime endTime  = LocalTime.of(<span class=\"number\">1</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>,<span class=\"number\">234</span>);</span><br><span class=\"line\">        Duration duration = Duration.between(startTime,endTime);</span><br><span class=\"line\">        System.out.println(duration.isNegative());</span><br></pre></td></tr></table></figure></li>\n<li>使用该类的plusXXX()方法、minusXXX()方法可以进行日期的增加和减少<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例(使用该类中的ofDays方法也可以获取Duration对象)</span></span><br><span class=\"line\">        Duration durationDays = Duration.ofDays(<span class=\"number\">1</span>);</span><br><span class=\"line\">        String addDays = durationDays.plusDays(<span class=\"number\">1</span>).toString();</span><br><span class=\"line\">        System.out.println(durationDays.getSeconds());</span><br><span class=\"line\"></span><br><span class=\"line\">        Duration durationHours = Duration.ofHours(<span class=\"number\">3</span>);</span><br><span class=\"line\">        String minusHours = durationHours.minusHours(<span class=\"number\">1</span>).toString();</span><br><span class=\"line\">        System.out.println(durationHours.getSeconds());</span><br><span class=\"line\"></span><br><span class=\"line\">        Duration durationMinutes = Duration.ofMinutes(<span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println(durationMinutes.getSeconds());</span><br><span class=\"line\"></span><br><span class=\"line\">        Duration durationMillis = Duration.ofMillis(<span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println(durationMillis.getSeconds());</span><br><span class=\"line\">        System.out.println(durationMillis.getNano());</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<hr>\n<h4>六.Instant类</h4>\n概述：表示某个时间，不带时区的即时时间点，精确到纳秒\n\n<p>内部由两个Long字段组成，第一部分保存自标准Java时代到现在的秒数，第二部分保存的是纳秒数(不会超过999,999,999)。<strong>注意：通过这种方式获取的时间戳与北京时间相差8个时区，需要修正为北京时间，通过查看源代码发现Instant.now()使用等是UTC时间Clock.systemUTC().instant()。LocalDate、LocalDateTime 的now()方法使用的是系统默认时区 不存在Instant.now()的时间问题。</strong></p>\n<ol>\n<li>Instant相当于Date,以下是相互转换<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例</span></span><br><span class=\"line\">        <span class=\"comment\">//类方法java.time.Instant</span></span><br><span class=\"line\">        Instant instant = Instant.now();</span><br><span class=\"line\">        System.out.println(instant);</span><br><span class=\"line\">        Instant beijingTime = Instant.now().plus(<span class=\"number\">8</span>, ChronoUnit.HOURS);</span><br><span class=\"line\">        System.out.println(beijingTime);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//类方法java.util.Date</span></span><br><span class=\"line\">        Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        System.out.println(date);</span><br><span class=\"line\"></span><br><span class=\"line\">        date = Date.from(instant);</span><br><span class=\"line\">        System.out.println(date);</span><br><span class=\"line\"></span><br><span class=\"line\">        instant = date.toInstant();</span><br><span class=\"line\">        System.out.println(instant);</span><br></pre></td></tr></table></figure></li>\n<li>Instant类中通过固定时间转换为Instant对象的方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//根据Date转换为instant(java.util.Instant中方法)</span></span><br><span class=\"line\">Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">Instant instant = Instant.ofEpochMilli(date.getTime());</span><br><span class=\"line\">System.out.println(instant);</span><br><span class=\"line\"><span class=\"comment\">//根据毫秒转换为instant(java.util.Instant中方法)</span></span><br><span class=\"line\">instant = Instant.ofEpochMilli(<span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>);</span><br><span class=\"line\">System.out.println(instant);</span><br><span class=\"line\"><span class=\"comment\">//根据秒转换为instant(java.util.Instant中方法)</span></span><br><span class=\"line\">instant = Instant.ofEpochSecond(<span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span> * <span class=\"number\">5</span>);</span><br><span class=\"line\">System.out.println(instant);</span><br><span class=\"line\"><span class=\"comment\">//根据秒和纳秒转换为instant(java.util.Instant中方法)，这样得到的instant会包含纳秒的数据 1000000000纳秒（9位）=1秒</span></span><br><span class=\"line\">instant = Instant.ofEpochSecond(<span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>,<span class=\"number\">1000000000</span>*<span class=\"number\">60</span>);</span><br><span class=\"line\">System.out.println(instant);</span><br></pre></td></tr></table></figure></li>\n<li>Instant类中的parse方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例</span></span><br><span class=\"line\">        <span class=\"comment\">//该方法的入参仅支持UTC格式的字符串，而且date结果的字符串会报出DateTimeParseException异常</span></span><br><span class=\"line\">        Instant instant = Instant.parse(<span class=\"string\">\"2020-10-26T12:10:00Z\"</span>);</span><br><span class=\"line\">        System.out.println(instant);</span><br></pre></td></tr></table></figure></li>\n<li>Instant类中的加减日期方法(加)plus()和(减)minus()方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例</span></span><br><span class=\"line\">        <span class=\"comment\">//ChronoUnit位于java.time.temporal,Periodjava位于Java.time</span></span><br><span class=\"line\">        <span class=\"comment\">//plus()方法会产生一个新的instant对象</span></span><br><span class=\"line\">        <span class=\"comment\">//plus()方法给当前日期增加五天</span></span><br><span class=\"line\">        Instant instant = Instant.now();</span><br><span class=\"line\">        Instant instantAddDayOne = instant.plus(<span class=\"number\">5</span>, ChronoUnit.DAYS);</span><br><span class=\"line\">        Instant instantAddDayTwo = instant.plus(Period.ofDays(<span class=\"number\">5</span>));</span><br><span class=\"line\">        Instant instantAddDayTwo1 = instant.plus(Duration.ofDays(<span class=\"number\">5</span>));</span><br><span class=\"line\">        System.out.println(instantAddDayOne.toString());</span><br><span class=\"line\">        System.out.println(instantAddDayTwo.toString());</span><br><span class=\"line\">        System.out.println(instantAddDayTwo1.toString());</span><br><span class=\"line\">        System.out.println(instant == instantAddDayOne);</span><br><span class=\"line\">        <span class=\"comment\">//minus()方法会产生一个新的instant对象</span></span><br><span class=\"line\">        <span class=\"comment\">//minus()方法给当前日期减少五天</span></span><br><span class=\"line\">        Instant instantSubDay = instant.minus(<span class=\"number\">5</span>, ChronoUnit.DAYS);</span><br><span class=\"line\">        Instant instantSubDayTwo = instant.minus(Period.ofDays(<span class=\"number\">5</span>));</span><br><span class=\"line\">        Instant instantSubDayTwo1 = instant.minus(Duration.ofDays(<span class=\"number\">5</span>));</span><br><span class=\"line\">        System.out.println(instantSubDay);</span><br><span class=\"line\">        System.out.println(instantSubDayTwo);</span><br><span class=\"line\">        System.out.println(instantSubDayTwo1);</span><br><span class=\"line\">        System.out.println(instant == instantSubDayTwo);</span><br></pre></td></tr></table></figure></li>\n<li>Instant类中比较两个日期的大小<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例</span></span><br><span class=\"line\">        Instant instantNow = Instant.now();</span><br><span class=\"line\">        Instant instantAddDay = instantNow.plus(Duration.ofDays(<span class=\"number\">5</span>));</span><br><span class=\"line\">        <span class=\"comment\">//isAfter()方法判断instantAddDay是否在instantNow之后</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> flgAfter = instantAddDay.isAfter(instantNow);</span><br><span class=\"line\">        System.out.println(flgAfter);</span><br><span class=\"line\">        <span class=\"comment\">//isBefore()方法判断instantAddDay是否在instantNow之前</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> flgBefore = instantAddDay.isBefore(instantNow);</span><br><span class=\"line\">        System.out.println(flgBefore);</span><br><span class=\"line\">        <span class=\"comment\">//compareTo()方法比较，前者时间纳秒值大于后者返回1，小于返回-1，等于返回0</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result1 = instantAddDay.compareTo(instantNow);</span><br><span class=\"line\">        System.out.println(result1);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result2 = instantNow.compareTo(instantAddDay);</span><br><span class=\"line\">        System.out.println(result2);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result3 = instantNow.compareTo(instantNow);</span><br><span class=\"line\">        System.out.println(result3);</span><br></pre></td></tr></table></figure></li>\n<li>Instant类计算两个日期的差值<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例</span></span><br><span class=\"line\">        Instant instantNow = Instant.now();</span><br><span class=\"line\">        Instant instantAddDay = instantNow.plus(Duration.ofDays(<span class=\"number\">5</span>));</span><br><span class=\"line\">        <span class=\"comment\">//between()方法后者比前者大，返回正数，比前者小返回负数，相等返回0(ChronoUnit.DAYS位于java.time.temporal)</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> result1 = ChronoUnit.DAYS.between(instantNow, instantAddDay);</span><br><span class=\"line\">        System.out.println(result1);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> result2 = ChronoUnit.DAYS.between(instantAddDay, instantNow);</span><br><span class=\"line\">        System.out.println(result2);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> result3 = ChronoUnit.DAYS.between(instantNow, instantNow);</span><br><span class=\"line\">        System.out.println(result3);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<hr>\n<h4>七.LocalDateTime类</h4>\n概述：表示不带时区的日期及时间，替换之前的Calendar\n\n<p><strong>注意:</strong>看上去，LocalDateTime和Instant很象，但记得的是“Instant中是不带时区的即时时间点。可能有人说，即时的时间点 不就是日期＋时间么？看上去是这样的，但还是有所区别，比如LocalDateTime对于用户来说，可能就只是一个简单的日期和时间的概念，考虑如下的 例子：两个人都在2013年7月2日11点出生，第一个人是在英国出生，而第二个是在加尼福利亚，如果我们问他们是在什么时候出生的话，则他们看上去都是 在同样的时间出生（就是LocalDateTime所表达的），但如果我们根据时间线（如格林威治时间线）去仔细考察，则会发现在出生的人会比在英国出生的人稍微晚几个小时（这就是Instant所表达的概念，并且要将其转换为UTC格式的时间）。</p>\n<ol>\n<li>LocalDateTime获取当前时间(系统自带默认时间)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例</span></span><br><span class=\"line\">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class=\"line\">        System.out.println(localDateTime);</span><br></pre></td></tr></table></figure></li>\n<li>LoclaDateTime类中时间加减计算(加)plusXXX()和(减)minusXXX()方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例</span></span><br><span class=\"line\">        <span class=\"comment\">// plus()和minus()方法与Instant类中相同</span></span><br><span class=\"line\">        LocalDateTime localDateTime1 = localDateTime.plusHours(<span class=\"number\">5</span>);</span><br><span class=\"line\">        System.out.println(localDateTime1);</span><br><span class=\"line\">        System.out.println(localDateTime1 == localDateTime);</span><br><span class=\"line\">        LocalDateTime localDateTime2 = localDateTime.minusHours(<span class=\"number\">5</span>);</span><br><span class=\"line\">        System.out.println(localDateTime2);</span><br><span class=\"line\">        System.out.println(localDateTime2 == localDateTime);</span><br></pre></td></tr></table></figure></li>\n<li>LocalDateTime显示年月日，不显示时间;显示时间，不显示年月<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例</span></span><br><span class=\"line\">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class=\"line\">        <span class=\"comment\">//显示年月日，且增加两个月</span></span><br><span class=\"line\">        LocalDate localDate = localDateTime.toLocalDate().plusMonths(<span class=\"number\">2</span>);</span><br><span class=\"line\">        System.out.println(localDate);</span><br><span class=\"line\">        <span class=\"comment\">//显示时分秒毫秒，且减少两个小时</span></span><br><span class=\"line\">        LocalTime localTime = localDateTime.toLocalTime().minusHours(<span class=\"number\">2</span>);</span><br><span class=\"line\">        System.out.println(localTime);</span><br></pre></td></tr></table></figure></li>\n<li>LocalDateTime类中格式化日期的两种方式<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码示例</span></span><br><span class=\"line\">        <span class=\"comment\">//通过Instant类获取当前系统时间，ZoneId.systemDefault设置为系统默认时区</span></span><br><span class=\"line\">        <span class=\"comment\">//ZoneId位于java.time</span></span><br><span class=\"line\">        LocalDateTime localDateTime1 = LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());</span><br><span class=\"line\">        System.out.println(localDateTime1);</span><br><span class=\"line\">        <span class=\"comment\">//通过DateTimeFormatter类中的ofPattern方法获取自定义格式的系统时间，位于java.time.format</span></span><br><span class=\"line\">        String localDateTimeStr = localDateTime1.format(DateTimeFormatter.ofPattern(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>));</span><br><span class=\"line\">        System.out.println(localDateTimeStr);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<hr>\n<p><strong>文章借鉴处</strong></p>\n<ul>\n<li><a href=\"https://blog.csdn.net/fragrant_no1/article/details/83988042\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/fragrant_no1/article/details/83988042</a></li>\n<li><a href=\"https://blog.csdn.net/neweastsun/article/details/88770592\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/neweastsun/article/details/88770592</a></li>\n<li><a href=\"https://blog.csdn.net/liubenlong007/article/details/62039628\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liubenlong007/article/details/62039628</a></li>\n</ul>\n","comments":true,"link":"","tags":[{"name":"JavaApi","slug":"JavaApi","permalink":"https://carefulhuo.github.io/tags/JavaApi/"}]},{"title":"服务器性能问题排查","date":"2020-09-22T07:57:28.000Z","path":"posts/acb0bcb4/","text":"服务器性能问题一般有两种：高内存占用、高CPU占用，比如应用程序高内存占用，可能是因为文件读写、频繁的IO、内存频繁GC，进一步占用了内存和CPU；比如应用程序高CPU占用，可能是因为大任务计算、死循环、卡死、不断超时或者重试。所以需要具体问题具体分析。 高内存占用现象是应用响应慢、内存溢出、应用进程直接死掉。体现到代码里面可能是死锁1和饥饿2，因为资源不释放;需要关注，空闲可用内存还有多少，buff[(Page Cache)是一种高速缓存，用于CPU和内存之间的缓冲 ,是文件系统的cache。]和cache[5]还有多少； 高CPU占用现象是应用进程还活着，但是页面出不来，不响应。体现到代码里面可能是存在活锁3。在CPU占用高的情况下，需要知道是用户（user）还是系统（sys）的占用率高，如果是user的CPU占用高，说明应用在做消耗CPU过高的操作；如果是sys的CPU占用高，说明系统在做大量的IO的操作；如果占用率高的线程频繁变动，则可能是CPU时间片不断调度，线程唤醒一下而后换另一个线程跑，需要看多线程任务是否存在大计算问题，以及线程池设置是否合适！","content":"<p>　　服务器性能问题一般有两种：高内存占用、高CPU占用，比如应用程序高内存占用，可能是因为文件读写、频繁的IO、内存频繁GC，进一步占用了内存和CPU；比如应用程序高CPU占用，可能是因为大任务计算、死循环、卡死、不断超时或者重试。所以需要具体问题具体分析。</p>\n<a id=\"more\"></a>\n<p>　　高内存占用现象是应用响应慢、内存溢出、应用进程直接死掉。体现到代码里面可能是死锁<a href=\"由于执行顺序的原因，互相持有对方正在等待的锁；多个线程在相同的资源上发生等待\">1</a>和饥饿<a href=\"高优先级线程一直占用CPU，导致低优先级线程一直处于一个等待进入同步块的状态\">2</a>，因为资源不释放;需要关注，空闲可用内存还有多少，buff[(Page Cache)是一种高速缓存，用于CPU和内存之间的缓冲 ,是文件系统的cache。]和cache[5]还有多少；<br>　　高CPU占用现象是应用进程还活着，但是页面出不来，不响应。体现到代码里面可能是存在活锁<a href=\"并未产生线程阻塞，但是由于某种问题的存在，导致无法继续执行的情况\">3</a>。在CPU占用高的情况下，需要知道是用户（user）还是系统（sys）的占用率高，如果是user的CPU占用高，说明应用在做消耗CPU过高的操作；如果是sys的CPU占用高，说明系统在做大量的IO的操作；如果占用率高的线程频繁变动，则可能是CPU时间片不断调度，线程唤醒一下而后换另一个线程跑，需要看多线程任务是否存在大计算问题，以及线程池设置是否合适！</p>\n","comments":true,"link":"","tags":[{"name":"Server","slug":"Server","permalink":"https://carefulhuo.github.io/tags/Server/"}]},{"title":"https基础概念","date":"2020-07-05T07:32:59.000Z","path":"posts/8ac28a0d/","text":"Http协议 什么是HTTP协议？ HTTP协议是一种超文本传输协议，是一种请求，响应式协议。 HTTP协议的特点 支持浏览器(客户端)/服务器模式 简单快速，浏览器向服务器发起请求时，只需要传送请求方式和路径 灵活，可以发送任意类型的数据 无状态，Http是无状态协议，无状态是指对事物处理没有记忆能力 HTTP消息 HTTP消息有几种？ 两种，一个请求消息，一个响应消息。 请求和响应的定义 当浏览器向服务器发送请求数据的时候，即http请求消息 当服务器向浏览器发送响应数据的时候，即http响应消息 HTTP请求消息 http请求包含几个部分？ 三个部分，请求方式，资源路径，http版本 http常用的请求方式 请求方式 含义 GET 请求获取请求行URL所标识的资源 POST 向指定资源提交数据，请求服务器进行处理 HEAD 请求获取由URL所标识资源的响应消息头 PUT 将网页放到指定的URL位置上(上传/移动) DELETE 请求服务器删除URL所标识的资源 TRACE 请求服务器回送收到的请求消息，主要用于测试和诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或查询与资源相关的选项和需求 注意：浏览器表单默认的是GET请求 请求方式 区别 GET 请求方式的参数信息都会在URL地址栏显示，而且通过请求参数传递数据，所以最多不超过1KB大小 POST 请求内容隐藏在实体内容中，通过实体内容进行数据传递，所以没有数据大小限制 请求头字段 含义 Accept:text/html 客户端希望接收HTML文本 Accept:image/gif 客户端希望接收GIF格式的图像资源 Accept:image/* 客户端可以接收所有image格式的子类型 Accept:*/* 客户端可以接收任意类型的数据 Accept-Charset 告知服务端，客户端所用的字符集 Accept-Encoding 用于指定客户端能够进行解码的数据编码方式 Accept-Language 客户端期望服务端返回那个国家的语言文档 Host 指定资源所在的主机和端口号 Max-Forward 指当前请求可以经过的代理服务器数量,每经过一个，数量减一 Referer 单击超链接向服务器发送GET请求时，浏览器会在发送的请求中加上该字段(防止盗链) User-Agent 指定浏览器或者其他客户端程序所使用的操作系统及版本，浏览器及版本，浏览器渲染引擎，浏览器语言 HTTP响应消息 HTTP响应消息包含几个部分 三个部分，响应状态行、响应消息头实体内容 响应状态行 HTTP版本 1.0、1.1 状态码及描述信息 状态码 描述信息 1xx 请求已经接受，需要继续处理 2xx 请求已经被服务器成功理解并接受 3xx 为完成请求，客户端需进一步细化请求 4xx 客户端的请求有错误 5xx 服务端出现错误 常用的状态码 状态码 状态信息 描述信息 200 正常 客户端请求成功，响应消息返回正常的请求结果 400 请求无效 客户端不正确的语法格式 403 禁止 服务端理解客户端的请求，但是拒绝处理 404 找不到 表示服务器不存在客户端存在的资源 500 内部服务器错误 大部分情况下是服务器端的CGI，jsp, ASP出现错误 响应消息头 说明 服务器端向客户端传递附加信息，包括服务程序名，被请求资源需要的认证方式，重定向地址，客户端请求资源的最后修改时间。 常见的响应消息头 响应消息头 描述内容 Accept-Range 说明服务器是否接收客户端使用Range请求头字段请求资源 Age 指出当前网页文档可以在客户端或代理服务器中缓存的有效时间 Etag 用于向客户端传送代表实体内容特征的标记信息，这些标记信息也称为实体标签，每个版本资源的实体标签是不同的，通过这个标签可以判断不同时间下，同一资源路径下的实体内容是否相同 Location 用于通知客户端获取请求文档的新地址 Retry-After 该字段可以与503状态码配合使用，告诉客户端什么时候可以重新发送请求，也可以与任何一个3xx状态码配合使用，告诉客户端处理重定向的最小延时时间 Server 用于指定服务器软件产品的名称 Vary 用于指定影响了服务器所生成的响应内容的那些请求头字段名 Refresh 用于告诉浏览器自动刷新页面的时间，是以秒为基本单位 Content-Disposition 用于服务器希望浏览器直接处理响应的实体内容，而是让用户选择将实体内容保存到一个文件中 实体内容 服务器根据客户端的请求所做出的处理结果 HTTP(请求或响应)消息中的其他字段 通用字段 字段名 字段描述 Cache-Control 用于通知位于客户端与服务器之间的代理服务器如何使用已缓存的页面 Connection 用于指定处理完本次请求/响应后，客户端与服务器是否还要保持连接 Date 用于表示HTTP消息产生的当前时间 Pragma 通知代理服务器和客户端如何使用缓存页面- Transfer-Encoding 通过该字段通知客户端响应数据的长度，因为HTTP1.1协议是持久化协议 Via 用于指定HTTP消息所途径的代理服务器所使用的协议与主机名 Warning 用于说明其他头字段和状态码不能说明的一些警告信息 实体头字段 字段名 字段描述 Allow 指定请求资源所支持的请求方式 Content-Language 用于指定返回网页文档的国家语言类型 Content-Length 用于表示实体内容的长度 Content-Location 用于指定响应消息中实体内容的实际位置路径(当一个请求资源有多个国家语言版本的时候，每个国家语言版本都有自己的位置，这时，请求资源路径和响应的实体内容的实际位置路径可能是不同的) Content-Type Content-Encoding 用于指定实体内容的压缩编码格式，服务器端对实体内容的压缩不影响实体内容的MIME类型，被压缩的实体内容在客户端被解压的时候，MIME类型与Content-Type头字段指定的类型一致 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","content":"<h4 id=\"Http协议\"><a href=\"#Http协议\" class=\"headerlink\" title=\"Http协议\"></a>Http协议</h4><ol>\n<li><strong>什么是HTTP协议？</strong><br> HTTP协议是一种超文本传输协议，是一种请求，响应式协议。<a id=\"more\"></a></li>\n<li><strong>HTTP协议的特点</strong><ol>\n<li>支持浏览器(客户端)/服务器模式</li>\n<li>简单快速，浏览器向服务器发起请求时，只需要传送请求方式和路径</li>\n<li>灵活，可以发送任意类型的数据</li>\n<li>无状态，Http是无状态协议，无状态是指对事物处理没有记忆能力</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h4 id=\"HTTP消息\"><a href=\"#HTTP消息\" class=\"headerlink\" title=\"HTTP消息\"></a>HTTP消息</h4><ol>\n<li><p><strong>HTTP消息有几种？</strong></p>\n<p> 两种，一个请求消息，一个响应消息。</p>\n</li>\n<li><p><strong>请求和响应的定义</strong></p>\n<ol>\n<li>当浏览器向服务器发送请求数据的时候，即http请求消息</li>\n<li>当服务器向浏览器发送响应数据的时候，即http响应消息</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h4 id=\"HTTP请求消息\"><a href=\"#HTTP请求消息\" class=\"headerlink\" title=\"HTTP请求消息\"></a>HTTP请求消息</h4><ol>\n<li><p><strong>http请求包含几个部分？</strong></p>\n<p> 三个部分，请求方式，资源路径，http版本</p>\n</li>\n<li><p><strong>http常用的请求方式</strong></p>\n<table>\n<thead>\n<tr>\n<th>请求方式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GET</td>\n<td>请求获取请求行URL所标识的资源</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>向指定资源提交数据，请求服务器进行处理</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>请求获取由URL所标识资源的响应消息头</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>将网页放到指定的URL位置上(上传/移动)</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>请求服务器删除URL所标识的资源</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>请求服务器回送收到的请求消息，主要用于测试和诊断</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>保留将来使用</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>请求查询服务器的性能，或查询与资源相关的选项和需求</td>\n</tr>\n</tbody></table>\n<h6 id=\"注意：浏览器表单默认的是GET请求\"><a href=\"#注意：浏览器表单默认的是GET请求\" class=\"headerlink\" title=\"注意：浏览器表单默认的是GET请求\"></a><em>注意：浏览器表单默认的是GET请求</em></h6><table>\n<thead>\n<tr>\n<th>请求方式</th>\n<th>区别</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GET</td>\n<td>请求方式的参数信息都会在URL地址栏显示，而且通过请求参数传递数据，所以最多不超过1KB大小</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>请求内容隐藏在实体内容中，通过实体内容进行数据传递，所以没有数据大小限制</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>请求头字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept:text/html</td>\n<td>客户端希望接收HTML文本</td>\n</tr>\n<tr>\n<td>Accept:image/gif</td>\n<td>客户端希望接收GIF格式的图像资源</td>\n</tr>\n<tr>\n<td>Accept:image/*</td>\n<td>客户端可以接收所有image格式的子类型</td>\n</tr>\n<tr>\n<td>Accept:*/*</td>\n<td>客户端可以接收任意类型的数据</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>告知服务端，客户端所用的字符集</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>用于指定客户端能够进行解码的数据编码方式</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>客户端期望服务端返回那个国家的语言文档</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>指定资源所在的主机和端口号</td>\n</tr>\n<tr>\n<td>Max-Forward</td>\n<td>指当前请求可以经过的代理服务器数量,每经过一个，数量减一</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>单击超链接向服务器发送GET请求时，浏览器会在发送的请求中加上该字段(防止盗链)</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>指定浏览器或者其他客户端程序所使用的操作系统及版本，浏览器及版本，浏览器渲染引擎，浏览器语言</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h4 id=\"HTTP响应消息\"><a href=\"#HTTP响应消息\" class=\"headerlink\" title=\"HTTP响应消息\"></a>HTTP响应消息</h4><ol>\n<li><p><strong>HTTP响应消息包含几个部分</strong></p>\n<p> 三个部分，响应状态行、响应消息头实体内容</p>\n</li>\n<li><p><strong>响应状态行</strong></p>\n<ol>\n<li><p><em>HTTP版本</em><br> 1.0、1.1</p>\n</li>\n<li><p><em>状态码及描述信息</em></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>描述信息</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1xx</td>\n<td>请求已经接受，需要继续处理</td>\n</tr>\n<tr>\n<td>2xx</td>\n<td>请求已经被服务器成功理解并接受</td>\n</tr>\n<tr>\n<td>3xx</td>\n<td>为完成请求，客户端需进一步细化请求</td>\n</tr>\n<tr>\n<td>4xx</td>\n<td>客户端的请求有错误</td>\n</tr>\n<tr>\n<td>5xx</td>\n<td>服务端出现错误</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><em>常用的状态码</em></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>状态信息</th>\n<th>描述信息</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>200</td>\n<td>正常</td>\n<td>客户端请求成功，响应消息返回正常的请求结果</td>\n</tr>\n<tr>\n<td>400</td>\n<td>请求无效</td>\n<td>客户端不正确的语法格式</td>\n</tr>\n<tr>\n<td>403</td>\n<td>禁止</td>\n<td>服务端理解客户端的请求，但是拒绝处理</td>\n</tr>\n<tr>\n<td>404</td>\n<td>找不到</td>\n<td>表示服务器不存在客户端存在的资源</td>\n</tr>\n<tr>\n<td>500</td>\n<td>内部服务器错误</td>\n<td>大部分情况下是服务器端的CGI，jsp, ASP出现错误</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n</li>\n<li><p><strong>响应消息头</strong></p>\n<ol>\n<li><p><em>说明</em></p>\n<p> 服务器端向客户端传递附加信息，包括服务程序名，被请求资源需要的认证方式，重定向地址，客户端请求资源的最后修改时间。</p>\n</li>\n<li><p><em>常见的响应消息头</em></p>\n<table>\n<thead>\n<tr>\n<th>响应消息头</th>\n<th>描述内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept-Range</td>\n<td>说明服务器是否接收客户端使用Range请求头字段请求资源</td>\n</tr>\n<tr>\n<td>Age</td>\n<td>指出当前网页文档可以在客户端或代理服务器中缓存的有效时间</td>\n</tr>\n<tr>\n<td>Etag</td>\n<td>用于向客户端传送代表实体内容特征的标记信息，这些标记信息也称为实体标签，每个版本资源的实体标签是不同的，通过这个标签可以判断不同时间下，同一资源路径下的实体内容是否相同</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>用于通知客户端获取请求文档的新地址</td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>该字段可以与503状态码配合使用，告诉客户端什么时候可以重新发送请求，也可以与任何一个3xx状态码配合使用，告诉客户端处理重定向的最小延时时间</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>用于指定服务器软件产品的名称</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>用于指定影响了服务器所生成的响应内容的那些请求头字段名</td>\n</tr>\n<tr>\n<td>Refresh</td>\n<td>用于告诉浏览器自动刷新页面的时间，是以秒为基本单位</td>\n</tr>\n<tr>\n<td>Content-Disposition</td>\n<td>用于服务器希望浏览器直接处理响应的实体内容，而是让用户选择将实体内容保存到一个文件中</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n</li>\n<li><p><strong>实体内容</strong></p>\n<p> 服务器根据客户端的请求所做出的处理结果</p>\n</li>\n</ol>\n<h4 id=\"HTTP-请求或响应-消息中的其他字段\"><a href=\"#HTTP-请求或响应-消息中的其他字段\" class=\"headerlink\" title=\"HTTP(请求或响应)消息中的其他字段\"></a>HTTP(请求或响应)消息中的其他字段</h4><ol>\n<li><p><strong>通用字段</strong></p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>字段描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache-Control</td>\n<td>用于通知位于客户端与服务器之间的代理服务器如何使用已缓存的页面</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>用于指定处理完本次请求/响应后，客户端与服务器是否还要保持连接</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>用于表示HTTP消息产生的当前时间</td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>通知代理服务器和客户端如何使用缓存页面-</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>通过该字段通知客户端响应数据的长度，因为HTTP1.1协议是持久化协议</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>用于指定HTTP消息所途径的代理服务器所使用的协议与主机名</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>用于说明其他头字段和状态码不能说明的一些警告信息</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>实体头字段</strong>   </p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>字段描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Allow</td>\n<td>指定请求资源所支持的请求方式</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>用于指定返回网页文档的国家语言类型</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>用于表示实体内容的长度</td>\n</tr>\n<tr>\n<td>Content-Location</td>\n<td>用于指定响应消息中实体内容的实际位置路径(当一个请求资源有多个国家语言版本的时候，每个国家语言版本都有自己的位置，这时，请求资源路径和响应的实体内容的实际位置路径可能是不同的)</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td></td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>用于指定实体内容的压缩编码格式，服务器端对实体内容的压缩不影响实体内容的MIME类型，被压缩的实体内容在客户端被解压的时候，MIME类型与Content-Type头字段指定的类型一致</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","comments":true,"link":"","tags":[{"name":"网络","slug":"网络","permalink":"https://carefulhuo.github.io/tags/%E7%BD%91%E7%BB%9C/"}]}]